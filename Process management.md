[TOC]

👆目录待优化

知识框架（有空更新）：

- [x] 进程的描述
- [x] 进程控制
- [x] 进程通信
- [x] 线程的基本概念
- [x] 线程实现
- [x] 处理机调度
- [x] 进程同步
- [x] 死锁

**前言:**

本文章单方面记录作者的学习历程,限于资历和阅读量,部分内容可能无法照顾到所有的读者.或者是存在某些内容不够充分,解读不够深入的地方,还望各位海涵!😁

文章会不定期更新,同时也期待和大家一起共享 探讨有关408的知识(～￣▽￣)～

![](E:\每日三省吾身\imgs\GOOD.png)

## 进程的描述



📚为何引入进程概念?



```
```

✨基于多个方面，分析进程和程序的区别





```
```

参考文章:	

[操作系统与操作系统内核 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/148389524)

[了解操作系统内核 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/81883894)

**知识点：**

---------

- [x] 程序顺序执行和并发执行的特征
  - 封闭性：指程序运行时独占全机资源，且资源状态只有本程序才能改变它，其执行结果不受外界因素影响
  - 可再现性：只要程序执行时的环境和初始条件相同，不论程序如何执行，其执行结果都相同
  - 顺序性：处理机按照程序给定的顺序执行



>  ❓并发执行时为什么会失去封闭性和可再现性？ --多个程序并发执行时，**系统资源将为它们所共享**，因而这些资源的状态也可由这些程序改变，致使失去封闭性 ，其**计算结果也和并发进程的执行速度有关** ， 致使执行结果不一样 ，失去可再现性。

### 📌进程的定义

- [x] 进程的定义

- 进程实体（进程映像）：由**程序段、数据段和PCB**组成
- 进程是进程实体的运行过程，是系统进行资源分配和处理机调度的基本单位

### 📌进程的特征

- [x] 进程的特征

- 动态性：是进程最基本的特征 ；”动态“具体表现为进程的七状态模型 ；
- 并发性：多个进程实体同时存在于内存中，可在同一时间内并发执行
- 独立性：指能够独立运行 、 独立获取资源分配 、接收调度的基本单位
- 异步性：各个进程按不可预知的速度向前推进 ，导致程序参与并发执行 ，所产生的结果具有不可再现性， 为**使进程在并发执行时虽具异步性，但仍保证进程执行结果是可再现性的** ，OS中应配置进程同步机制。

### 📌状态转换模型

- [ ] 五/七状态模型（五状态模型为主）
- 创建状态： 进程所需资源不能得到满足时，创建工作尚未完成 ，进程无法被调度运行 ，此时处于**创建态** ；（引入挂起状态后，进程无法得到内存分配的空间，被安置在外存，无法调度时 **处于静态就绪**） 
- 创建态->就绪态：处于创建态的进程 ，当其获得了所需的资源且==其PCB的初始化工作完成==后 ， 便可转入**就绪态**

---

>  七模型展示图:

![image-20221103183141028](E:\每日三省吾身\imgs\image-20221103183141028.png)

> 📕引发创建进程的事件有？创建进程的步骤具体为？
>
> 创建进程的事件：
>
> 1. 用户登陆
> 2. 提供服务
> 3. 作业调度
> 4. 应用请求（由用户进程创建新进程）
>
> 创建进程的步骤：
> 
> 1. 调用进程创建原语create
> 2. 申请空白的PCB
> 3. 分配进程所需资源
> 4. **初始化PCB**
> 5. 将进程插入到就绪队列中
>
> ❓引起进程挂起(suspend)操作的原因？
>
> 1. 父进程请求
> 2. 终端用户的需要
> 3. 操作系统的需要
> 4. 负荷调节需要：保证实时任务的执行

> ❓引起进程阻塞(block)操作的原因？
>
> 1. 等待新任务的到达
> 2. 等待某种操作完成
> 3. 没有新数据到达
> 4. 向系统请求共享资源失败

> ❓为什么运行态 -> 阻塞态 -> 就绪态是单向的？ 
>
> 阻塞态到就绪态是不受进程自身控制的，是**被动行为** ； 运行态到阻塞态是**进程自身做出的主动行为** 

> ❓阻塞和挂起的区别是？
>
> 1. **对系统资源占用不同**：阻塞进程映像保留在内存，挂起态进程映像存在于外存。
> 2. **发生时机不同**：进程阻塞/挂起都是主动行为 ；但造成原因不一样。
> 3. **恢复时机不同**：~~阻塞恢复是被动行为，挂起恢复是主动行为 ；阻塞态进程需要其它进程/系统唤醒 ，不存在对应主动行为唤醒自己 ；倘若采用的是抢占式调度策略，就绪挂起态进程可根据自身优先级 剥夺当前进程的运行 。~~
>
> ~~阻塞要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行；被挂起的进程由将其挂起的对象（如用户、系统）在时机符合时（调试结束、被调度进程选中需要重新执行）将其主动激活~~
>
> 参考文章：
>
> [阻塞与挂起的区别_么滴感情de杀手的博客-CSDN博客_阻塞和挂起的区别](https://blog.csdn.net/hqy1719239337/article/details/100543307)
>
> [进程的基本状态及转换和阻塞及挂起的理解_邪三一的博客-CSDN博客_进程的阻塞状态](https://blog.csdn.net/Caoyang_He/article/details/80791581)

---

### 📌进程管理的数据结构

- [x] 进程管理中的数据结构
- 具体分类
  - 内存表
  - 设备表
  - 文件表
  - 进程表（进程控制块） PCB
- PCB包含信息
  - 进程标识符
  - 处理机状态
  - 进程调度信息
  - 进程控制信息

- PCB的作用
  - 作为独立运行基本单位的标志
  - 实现与其它进程的同步与通信
  - 实现间断性运行方式
  - 提供进程管理所需要的信息
  - 提供进程调度所需要的信息
- PCB的组织方式
  - 线性方式
    - 定义：将系统中的所有的PCB都组织在一张线性表中，并将表的首地址记录在内存的专用区域中。
  - 链接方式
    - 定义：把具有相同状态进程的PCB分别通过PCB的链接字链接成一个队列
  - 索引方式
    - 定义：系统根据所有进程状态的不同，建立多张索引表，并把各索引表的在内存中的首地址记录在内存的特定单元中。
- PCB的初始化过程 （详见答疑处）

----

> ❓为什么没有CPU表？ 
>
> PCB控制块中已然包含关于处理机状态信息（处理机上下文），当进程切换时，进程重新执行能够根据PCB中的处理机上下文从断点继续执行

> ❓ PCB的初始化过程？
>
> 1. 初始化标识符信息
> 2. 初始化处理机状态信息
> 3. 初始化处理机控制信息

---



## 进程通信



**知识点：**

### 📌进程通信的类型

- [x] 进程通信的类型
- 共享存储器系统
  - 基于共享数据结构（由程序员实现）
  - 基于共享存储区（由进程负责）
- 管道通信系统（半双工通信即单向）
- 消息传递系统
  - 直接通信方式/直接通信传递系统（通过OS原语Send/Receive）
    - 通信链路
      - 采用TCP/UDP协议建立连接
      - 分类为单向/双向通信链路
  - 间接通信方式（通过中间实体邮箱）
    - 邮箱分类
      - 私有（用户自行创建）
      - 公有（由OS创建）
      - 共享（某进程创建）
    - 发送进程和接收进程存在关系：
      - 一对多：广播方式传递
      - 多对一：CS交互
      - 一对一：点对点通信
      - 多对多：建立公用邮箱，自己拿自己的信件
- C/S系统
  - 套接字
    - 基于文件型
    - 基于网络型
  - 远程方法调用
  - 远程过程调用

----

> ❓为什么进程通信需要操作系统来支持呢?
>
> 其一是进程是分配系统资源的单位（包括内存地址空间），且各进程拥有自己的内存地址空间并且相互**独立**，为了安全不能让一个进程访问其它进程的地址空间；
>
> 另外拿信号量机制举🌰 ， 它的**效率低**：生产者每次只能向缓冲区投递一个产品（消息），消费者每次也只能从其中取得一个消息 ；**通信对用户不透明**，OS只为进程间的通信提供了共享存储器 ，其它的比如数据结构的设置、进程互斥同步等操作都需要程序员去实现 故对用户而言是极其不方便的。

## 进程同步

知识点：

### 📌进程同步的概念

- [x] 进程同步的基本概念
- 临界资源
  - 指一段时间内只允许一个进程使用的资源,具有互斥性
- 互斥访问分区
  - 进入区：负责检测是否可以访问临界区 ；上锁阻止其它进程的进一步访问
  - **临界区**：访问临界资源
  - 退出区：负责解锁
  - 剩余区：其它后续处理
- 同步机制应遵循的机制
  - 空闲让进
  - 忙则等待
  - 有限等待
  - **让权等待**

### 📌互斥实现方式

- 互斥实现方法
  - 软件实现
    - 单标志法
    - 双标志法
    - 双标志法后检查
    - Peterson算法
  - 硬件实现
    - 关中断指令
    - Test_And_Set指令
    - Swap指令
  - **信号量机制实现**
    - 整型信号量（不满足让权等待原则）
    - **记录型信号量**(在初始化的基础上加了个等待队列 （阻塞队列），倘若资源不够用便会将进程插入队列中)
    - And型信号量
    - 信号量集
  - 管程机制
    - 管程的组成
      - 管程的名称
      - 局部于管程的共享数据结构说明（注释）
      - 操作数据结构的一组过程
      - 共享数据的初始化语句
    - 管程的特性
      - 模块化 ：可单独编译
      - 抽象数据类型 ：含数据以及对数据的操作
      - 信息掩蔽 ：供管程外的进程调用，其数据结构和过程实现方式对外不可见



> ❗临界资源再深入(提及特殊临界区和普通临界区的区别)
>
> **临界资源**指一段时间内只允许一个进程使用的资源,具有互斥性
>
> >  注意区分临界资源：临界资源属于**互斥共享资源**，非共享数据不属于临界资源，且其一段时间内只能被一个进程访问，🌰打印机、共享变量、共享缓冲区都只允许一次供一个进程使用	
>
> **临界区**指访问临界资源的那段代码
>
> **内核程序临界区**一般是用来访问**某种内核数据结构**,比如进程的就绪队列(由各就绪进程PCB组成) ；在访问内核程序临界区期间**不能进行调度和切换** ；因为内核程序临界区的临界资源不尽快释放的话 会影响到其它管理工作
>
> **普通临界区**访问的临界资源不会影响到内核管理工作，为系统的并发度增加CPU的利用率，因此在访问临界区时**可以进行调度和切换** .

> ❓临界资源和共享资源的区别在于？
>
> **在一段时间内能否允许被多个进程访问（并发访问）**；
>
> 
>
> ①**若代码可被多个进程在任意时刻共享**，则要求<u>任意一个进程</u>在调用此段代码时都**以相同的方式运行**；而且在运行过程中**被中断后再继续执行，其执行结果不受影响**，这必然要求共享的代码是不允许任何修改的代码■■■■■■■🌰**可重入代码**也称纯代码，且其是不允许被任何修改的代码，即允许多个进程同时访问的代码。
>
> ②临界区是指访问临界资源A的的那段代码，那么**n个并发进程共有n个操作共享变量A的代码段**

> ❓ 管程和进程的不同？
>
> 1. 进程定义的私有**数据结构**PCB，管程定义的公有数据结构 如消息队列
> 2. 都存在**对各自数据结构的操作**，进程**由顺序程序执行有关操作**，而管程主要进行同步操作和初始化操作
> 3. **引入目的不同**，前者是在于实现系统的并发性，而后者在于解决共享资源的互斥使用问题
> 4. **工作方式不同**，进程通过调用管程中的方法对其数据结构进行操作，因而前者为主动工作方式，后者为被动调用
> 5. 进程之间能**并发**执行，管程不能和调用者并发执行
> 6. 进程具有**动态性**，而管程是静态的代码模块，只能被调用

> ❓ 信号量中的P和V操作 与 管程中的wait和signal 有什么区别？（可能会更新）
>
> - 根据管程定义，**管程的`wait`操作一定会使后续进程进入等待状态**，**而`P`操作则未必 ，信号量是可以并发的** 。
> - 信号量中的**`V`操作总是执行 x = x + 1 的操作 ，因而总是会改变信号量的状态** ，管程中的signal具有自适应的效果，**仅当存在进程因为某个变量阻塞/挂起时，signal才会生效**并作用于其中的一个阻塞/挂起进程 ，否则不会产生任何结果
> - 和信号量一样，管程为了使得进程可以等待某一个条件变量，为每个条件变量设置了一个等待队列。但是和信号量不一样的是，**条件变量并不管理空闲资源的数量，而只是维护了等待当前条件变量的进程个数**
> - ~~管程中定义的条件变量只能在管程中进行访问 ， 信号量不一定~~
>
> ❓管程是如何实现互斥机理的？
>
> 封装于管程内部的数据结构仅能被同样封装于管程内部的过程访问，且进程只能通过管程间接访问系统资源，管程每次仅准许一个进程进入管程。从而实现互斥

参考文章：

[锁原理 - 信号量 vs 管程：JDK 为什么选择管程 - binarylei - 博客园 (cnblogs.com)](https://www.cnblogs.com/binarylei/p/12544002.html)

----

> ❓各类信号量的实现机理具体是、它们该如何实现进程间的前趋？
>
> ~~整型信号量定义了记录资源数目的整型变量，而记录型信号量在此基础上定义了进程链表指针，用于链接等待进程，AND信号量的实现机理是一次性分配进程运行所需要的全部资源，信号量集加强了每一次资源请求、释放个数，并规定了对资源请求的下限。为实现进程间的前趋关系，🌰存在进程P1的语句S1和进程P2的语句S2，欲先执行S1后执行S2，只需在S1后添加V操作，在S2前添加P操作~~



## 线程

知识点：

- [x] 线程基本概念
- 引入初衷
  - 在提高资源利用率和系统吞吐量的同时，减少程序并发执行的时空开销
- 多线程OS中的进程属性
  - 进程是资源分配的基本单位
  - 进程是处理机调度的基本单位
- 线程的实现
  - 内核级线程（可看作一对一模型）
    - 实现方式
      - 内核**支持**线程
  - 用户级线程（可看作多对一模型）
    - 实现方式
      - 运行时系统（用于管理和控制线程的函数的集合）
      - 内核**控制**线程

> ❗线程和进程的比较
>
> **调度的基本单位✔**：在引入线程后，**线程作为处理机的调度与分派的基本单位**，线程切换的代价远低于进程； 且**同一进程下的线程切换不会引起进程切换** ，但从一个进程的线程切换到另一个进程的线程时，必定会引起进程切换。
>
> **并发性**✔：引入线程，**同一个进程中的多个线程之间可并发执行** 比如QQ可以一边传文件一边打字聊天 ； 且**不同进程中的线程也能并发执行** ，比如一边打字聊天一边网易云☁。
>
> **拥有资源**✔：<u>**进程是资源分配的基本单位**</u> ；线程本身**不拥有系统资源**
>
> (仅有一点必不可少的、能保证运行的资源)，但**线程可以访问隶属进程的系统资源**。
>
> **独立性**✔：每个**进程**都拥有**独立的地址空间**和资源，除共享全局变量外 ，不允许其他进程访问；**同一进程的不同线程共享进程的内存地址空间和资源**，支持相互访问。
>
> **系统开销**✔： 进程的切换涉及到**上下文的切换** 开销很大；线程切换只需要保存和设置寄存器，**线程切换代价小** ；
>
> 且**在一些OS中，线程的切换、同步和通信都无需OS干预** ，因为一个进程的多个线程具有相同的地址空间。
>
> **支持多处理机系统** ：**对于单线程进程，不管有多少处理机，进程只能运行在一个处理机上。对于多线程进程，可将进程中的多个线程分配到多个处理机上执行**。





用户级线程ULT

1)优点：①**线程的切换**不需要转换到**内核空间**②**不同进程**可根据自身需要，对**自己的线程**使用**不同的调度算法**③**用户级线程的实现** 与 **操作系统无关**，对**线程管理**的代码是**用户程序**的一部分

2)缺点：①不能发挥多处理机的优势：内核每**一次**只分配给进程**一个CPU**，每次**只有一个线程可执行**②系统调用阻塞问题：线程**执行系统调用**发生阻塞，进程中的**所有线程**都被阻塞。





内核支持线程KST

1)优点：①能发挥多处理机的优势，内核可使同一进程下多个线程并行执行②一个线程发生阻塞不会影响其它线程的执行③内核本身可采用多线程技术，提高系统的效率

2)缺点：①同一进程下的不同线程切换涉及用户态和内核态的转换，开销大





多线程模型

1）多对一模型

优点：①线程管理是在用户空间进行的，效率高

缺点：①一个线程访问内核时发生阻塞，整个进程被阻塞②任何时刻，只允许一个线程访问内核

2）一对一模型

优点：一个线程发生阻塞不影响其它线程的运行

缺点：创建一个用户级线程，需要相应地创建一个内核级线程，开销大



>  ❓线程实现方式的区别？
>
> ~~**系统开销比较**： ①KST中用户进程的线程在用户态执行，而线程的调度和管理（创建、切换等操作）在内核中执行，模式切换致使系统开销大 ；②ULT用户级线程与内核无关，线程切换不需转换到内核空间，~~
>
> ~~**系统调用阻塞问题**：①当一个用户级线程阻塞时进程内的所有线程都会被阻塞 ；②而KST单个线程阻塞不会影响到其它线程的执行~~
>
> ~~**并发度**：①多处理机系统中,由于内核每次分配给一个进程的仅有一个CPU，一段时间内只允许一个ULT线程访问内核；②内核能够同时调度同一进程中的多个KST线程并行执行~~

个人简单描述一下**内核控制线程**实现机制：

- 用户级线程将 包含多个轻型进程LWP的缓冲池 代替线程库（类似于数据库池），只有连接到LWP上的线程才能与内核通信，其余进程或者阻塞或者等待LWP，即用户级线程可以选择性连接LWP；

- 关于阻塞：①**当内核级线程发生阻塞**时，和内核级线程连接的LWP也将随之阻塞，和LWP相连接的用户级线程会被阻塞 ，当**进程中只包含一个LWP**，**进程也应阻塞**；倘若进程执行系统调用时是阻塞态，②**即使所有的LWP全部阻塞**，进程中的线程依然能够执行 **只是不能再去访问内核**

![image-20221030175602075](E:\每日三省吾身\imgs\image-20221030175602075.png)



## 处理机调度

知识点：

- **实时系统算法分类**：

  - 按实时任务性质
    - 硬实时调度算法
    - 软实时调度算法

  - 按调度方式不同
    - 非抢占式
      - 非抢占轮转调度
      - 非抢占优先调度
    - 抢占式
      - 基于时间中断的优先级调度算法
      - 立即抢占的优先级调度算法


### 📌处理机调度及其调度算法

- 处理机调度层次
  - 高级调度（作业调度）
  - 中级调度（内存调度）
  - 低级调度（进程调度）
- 处理机算法的性能指标
  - 资源利用率
  - 系统吞吐量（单位时间内完成了多少作业）
  - 周转时间（作业从提交给系统开始到完成的总时间）
  - 等待时间（计算技巧：**周转时间-运行时间**）
  - 响应时间(等待时间+运行时间) 
- **进程调度的方式**
  - 非抢占式
  - 抢占式
    - 遵循原则：
      - 优先级原则
      - 短作业优先原则
      - 时间片原则
- 调度算法

  - 算法评估角度（有空再细🔒）

    - 算法思想、规则
    - 是否可抢占
    - 优缺点
    - 是否会导致饥饿
  - 作业调度算法分类（有空再细🔒）
  
    - 先来先服务FCFS
  
    - **短作业优先SJF**🔥
  
    - 优先级调度算法PSA
  
    - 高响应比优先算法HRRN
  - 进程调度算法分类
    - **时间片轮转**
      - 时间片过小，导致切换上下文操作频繁 ， 加大系统开销
      - 时间片过大，会导致算法退化成FCFS算法，无法满足短作业优先和交互式用户的需求
    - 优先级调度
      - 优先级类型
        - 静态优先级
        - 动态优先级
    - 多级反馈队列
  - 实时调度算法
    - 实时调度算法分类
      - 根据实时任务性质(软实时调度算法和硬实时调度算法)
      - 根据调度方式
        - 非抢占式调度算法
          - 非抢占式轮转调度算法
          - 非抢占式优先调度算法
  
        - 抢占式调度算法
          - 基于时钟中断的抢占式优先级调度算法（尽管优先级最高，时钟中断发生时，才抢占处理机）
          - 立即抢占的优先级调度算法（只要当前任务未处于临界区，便会剥夺当前任务的执行）
  
    - 最早截止时间优先EDF(截止时间越早，优先级越高)
    - 最低松弛度优先LLF(松弛度=**必须完成时间-本身运行时间-当前时间**，越低优先级越高，松弛度为0才发生调度)
    - 优先级倒置PIP
  

```
提问环节👇👇
```

> ❓优先级调度算法中的优先级如何设置？
>
> 关于静态优先级：
>
> 1. 进程类型
> 2. 进程所需资源类型
> 3. 用户要求
>
> 关于动态优先级：
>
> 1. 从追求**公平、提升资源利用率、系统吞吐量**的角度考虑：
>
> 2. 等待时间越长优先级越高 ；
>
> 3. 运行时间越长，优先级越低（防止优先级初始值过高的进程一直抢占处理机，导致算法退化）	；
>
> 4. 进程频繁使用IO操作，提高其优先级(IO繁忙型进程优先级高于CPU繁忙型进程)；

> ❓阐述优先级倒置?优先级倒置的解决方法?
>
> 定义：
>
> > **高优先级进程被低优先级进程延迟或阻塞**（处于临界区仍然会被优先级高的进程抢占）
>
> <u>虚假的定义以及解决方案描述</u>：
>
> 大姐、二姐、弟弟：弟弟和大姐都想用电视机玩游戏**(临界资源)**，但同一时间内只能由一人霸占电视机。弟弟玩得正尽兴，二姐手握遥控器想看偶像剧。不一会儿大姐来了，支开二姐想玩游戏但发现手柄在弟弟手里**（相当于阻塞在P(mutex)）**。无奈只能等二姐看完偶像剧为止，并等待弟弟玩完游戏为止**(离开临界区V (mutex))**，大姐才能上位玩游戏。
>
> Real**解决方案**：①管你是谁，“我”的电视我做主②同为游戏人，弟弟可以选择让大姐看自己打游戏，以防被二姐gank
>
> > ①进程进入临界区后，该进程所占用的**处理机不允许被抢占**
> >
> > ②当高优先级进程T1进入临界区访问临界资源时，倘若已存在低优先级进程T2正在访问临界区，此时一方面T1被阻塞，另一方面T2**继承T1的优先级**并一直保持到T2退出临界区

> 📉实时系统中的处理机能力要求高的缘由：
>
> - **实时系统**中包含要求满足响应时间的非实时任务和要求完成时限的实时任务，倘若处理机能力不强会因为自身处理不过来，致使任务处理不及时
> 







## 🌠死锁

定义：

如果一组进程中的每一个进程都在等待由该组进程中的其它进程才能引发的事件，那么这组进程是死锁的。

**🛒知识点**：

- 资源分类
  - 可重用性资源(进程运行期间不可创建、删除)
  - 可消耗性资源
  - 不可抢占性资源(磁带机、打印机)
  - 可抢占性资源(CPU、主存)
- 引发死锁的原由
  - 竞争不可抢占性资源
  - 竞争可消耗性资源
  - 进程推进顺序不当
- 产生死锁的必要条件🔥
  - 请求和保持条件
  - 循环等待条件
  - 不可抢占条件
  - 互斥条件

- 处理死锁的方法
  - **预防死锁**（破坏必要条件）
  - **避免死锁**（银行家算法）
  - **检测死锁**
    - 死锁定理(简化资源分配图)
  - **解除死锁**
    - 抢占资源
    - 终止进程

```
提问环节👇👇
```

> ❓可重用资源和可消耗性资源的性质:（🛠待进一步完善）
>
> 1. 前者不能被多个进程共享使用，后者可以
> 2. 前者资源数目相对固定，进程运行期间无法创建或删除它；后者资源数目在进程运行期间是可以不断变化的，可参考生产者和消费者问题。

>  ❓如何破坏必要条件?
>
>  - 破坏互斥条件：
>
>  1. 由于互斥条件是非共享设备所必须的，不仅**不能改变**，还应加以保证
>
>  - 破坏请求和保持条件：
>   1. 进程运行前，**一次性申请**所需要的全部资源 ；但存在资源严重浪费、进程饥饿等缺点。
>   2. 先行获取**初期**运行**所需资源**，运行过程中**逐步释放**资源，或**逐步申请**自身所需资源 ；酱紫有效地提高资源的利用率。
>
>  - 破坏循环等待条件：
>   1. 对系统所有的资源类型进行线性排序并赋予不同的序号，规定进程**按照序号递增的顺序**请求资源。
>   2. 那么代价呢？限制了新设备的加入 ；限制用户自主地编程
>
>  - 破坏不可抢占条件:
>   1. 当一个进程已经保持了某些不可抢占资源，提出新的请求而不能得到满足时，它必须**释放已经保持的资源**，待以后需要时再**重新申请**。
>   2. 那么代价呢？进程前后两次运行的**信息不连续**，可能还会因为**反复**申请或撤销资源致使进程执行**被无限推迟**，不仅**延长进程的周转时间**，**增加**系统**开销**、减少系统**吞吐量**。

​	





## 习题总结



### 关于进程同步核心题（PV操作） 

```

```

预备知识点：

- 通常empty表示空闲缓冲区的数量 ，full表示某个产品的数量

- 使用互斥信号量mutex保证某个操作是一气呵成的！
- 分析什么地方需要实现同步关系，并保证PV两个操作是**一前一后**的 ;(即一个进程消耗某种资源前，可能需要另一个进程释放该资源)
- ❗注意**实现同步的P**操作代码和**实现互斥的P**操作代码尽量**不要颠倒顺序**，否则容易**产生死锁**

```

```

解题思路：

1. 先行判断有**几类**进程，每个进程对应一个函数

2. 在函数内部**用中文描述执行动作**（题目一般不会直接给出），并确定执行频率(一次OR反复)

3. **判断每个动作执行前**是否需要P操作（倘若有应写对应的V操作）❗注意隐含的互斥条件（通常出现在缓冲区）

4. 在所有PV写完之后再去定义信号量

   > ~~信号量的初值应根据具体情况来确定~~，若**期望的消息尚未产生**，则对应的初值应设为0；若**期望的消息已存在**，则信号量的初值应设为一个非0的正整数

5. 检测多个P操作连续出现的地方（是否出现请求和保持的现象），是否可能产生死锁？（出现死锁肿么办❓一般调换P操作的顺序）

```

```

题型：

- 生产者与消费者问题🔥
  - 解题思路：默认
  - 个人总结：同一个缓冲区上 ，涉及该缓冲区的不同进程中，每个进程至少存在一种围绕该缓冲区的P操作，即是否有东西可取或有空位可用。
  
- 服务与被服务问题
  - 思路:
  
    - > 先来先服务，等待队列数量有限；有顾客且服务他人有空时，所其它有顾客等待，佛祖额  
      >
      > ``` c
      > 伪代码
      > int num = 0;//等待服务的顾客
      > Semaphore Lock = 1;//互斥访问num
      > Semaphore rest = 0;//没人就休息
      > Semaphore wait = 0;//让顾客排队等待
      > Server(){
      >     while(1){
      >         P(Lock);
      >         if(num>0){
      >             num--;
      >             V(Lock);
      >             V(wait);//唤醒顾客
      >             为顾客服务;
      >         }else{
      >             V(Lock);
      >             P(rest);//服务人员休息
      >         }
      >     }
      > }
      > Customer(){
      >     P(Lock);
      >     if(num>等待人数上限){
      >         V(Lock);
      >         离开这家店
      >     }
      >     else{
      >         num++;
      >         V(Lock);
      >         V(rest);//唤醒一个正在等待的服务人员
      >         P(wait);//等待被服务
      >         被服务
      >     }
      > }
      >     
      >     
      > 
  
- 读者与写者问题
  - 本质：同类进程可以**共享访问**同一资源，不同类进程**互斥访问**同一资源
  - 解题思路：默认+ （用count变量记录、确保同类进程“第一个上锁最后一个解锁”，且上锁和解锁的过程是一气呵成的）
  
- 哲学家问题
  - 本质：只有一类进程同时拥有多种资源才能运行
  
  - 解题思路
    - 限制申请资源的顺序即单号拿左筷子双号拿右筷子(不通用)
    - 暴力解法✔（取得所有资源前先上个🔒，条件判断资源是否足够再解锁）
    - 信号量限制并行数🤔（确定至少资源数 ， **确保同一时间只有一个哲学家进餐** 即实现禁止并行）
    
    
    













