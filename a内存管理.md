

[TOC]



## 🌠存储器管理

知识点：

- 存储器的多层结构
  - 存储层级分类
    - 寄存器
    - 高速缓存（备份主存中常用的数据，以减少处理机对存储器的访问次数）
    - 主存
    - 磁盘缓存（**实际不存在**但作用和高速缓存相仿，主要用于暂时存储频繁使用的磁盘数据，实际是利用**主存的部分存储空间**来实现的）
    - 固定磁盘（掉电后不会丢失）
    - 可移动存储介质（掉电后不会丢失）
- 程序的装入和链接
  - 装入方式分类
    - 绝对装入方式
    - 可重定位装入方式
    - 动态运行时装入方式
  - 链接方式分类
    - 静态链接
      - 需要解决的问题：
        - 变换外部调用符号
        - 更改模块的逻辑地址
    - 装入时动态链接
      - 优点：
        - 便于实现对目标模块的共享
        - 便于修改和更新
    - 运行时动态链接
      - 优点：
        - 执行时链接 ， 益于节省内存空间
- 连续分配存储管理方式
  - 单一连续分配
    - 单道程序环境下的内存分为系统区(低地部分)和用户区
    - 优点：简单且无须进行内存保护
    - 缺点：只能运行一道程序，且容易产生内部碎片
  - 固定分区分配
    - 优点：实现简单，没有外部碎片
    - 缺点：①程序小于固定分区时存在空间浪费②不能实现多进程共享同一个主存区，存储空间利用率低
    - **划分分区方法**
      - <u>分区大小相等</u>（程序太小造成浪费，太大无法装入，**缺乏灵活性**）
      - 分区大小不等
  - 动态分区分配
    - 缺点：因为会产生外部碎片，内存的利用率随时间推移而下降
    - 动态分区分配算法
      - 按顺序搜索(按表或链的组织顺序，检索表或链的空闲分区记录)
        - 首次适应算法
        - 循环首次适应算法
        - 最佳适应算法
        - 最坏适应算法
      - 按索引搜索
        - 快速适应算法
        - 伙伴系统
        - 哈希算法

> ❓为什么采用多层结构的存储器系统？
>
> 计算机执行时几乎每一条指令都涉及到存储器，故要求存储器速度和CPU相仿、容量大的同时还便宜；简直异想天开，于是乎引入上述系统 ：其中高速缓存解决存储系统的速度问题，辅存解决系统容量问题 。



> ❓为什么访问辅存所需时间远大于访问可执行存储器(寄存器和主存)的时间？
>
> 进程能够在很短的时间周期内**利用一两条指令完成对可执行存储器的访问**，但**访问辅存是通过IO设备实现的**，于是乎涉及到中断、设备驱动程序以及物理设备，故访问时间比较大。



> ❓不同装入方式的区别？
>
> **①注意进场时机**：
>
> 绝对装入方式：只能**将目标模块装入到内存事先指定的位置** ；
>
> 可重定位装入： 当作业装入内存时**能够分配所有要求的内存空间** ,否则无法装入。装入后<u>在内存中无法移动</u>。在内存中<u>无法再次申请空间</u> ；
>
> 动态运行时装入 ：**装入程序==部分代码==后即可投入运行** ，且可放置在<u>不连续的存储区</u>中，运行期间可<u>动态申请内存空间</u>。
>
> **②地址变换时机不同**：绝对装入在**编译或汇编时**产生绝对地址 ，<u>静态重定位</u>在**装入时**将逻辑地址转换为物理地址 ，<u>动态重定位</u> 是在**运行时**将逻辑地址转换为物理地址，但需设置<u>定位寄存器</u>（作用：不影响指令的执行速度）。
>
> **③使用场合**：绝对装入只适用于**单道程序环境**，后两者适用于多道批处理系统



> 📕为什么要引入重定位？如何实现？
>
> 程序在执行的过程中经常在内存中移动位置，为**保证移动位置后还能正常运行**，需要将程序中代码、数据段的地址进行修改 ，故<u>引入重定位思想</u>。
>
> 在**不影响指令执行速度**的情况下实现地址变换，由重定位寄存器实现

> 📕回收内存可能出现的情况（此处以分区表为准）
>
> 待补充书中描述的插入点说法



<div class="ZD">
<img src="http://82.157.234.157/ForTakeNotes/image-20221101190309462.png" width = "100%" alt="***" />





> ❓不同链接方式的区别？
>
> ①**形成逻辑地址的时机不同**：
>
> 静态链接在**装入前**链接成一个完整装入模块 ；
>
> 装入时动态链接 是在**运行前**边装入边链接 ；
>
> 运行时动态链接 ，是在**运行时需要目标模块**才装入并链接

个人练习区（🐟供选择性观赏）：

> - **链接程序的功能**是： 将编译得到的一组<u>目标模块</u>和它们所需要的<u>库函数</u>装配成完整的<u>装入模块</u>

> - 📕静态链接概念：在装入前将所有的目标模块链接成整体并不再拆开。

> - 📕装入时动态链接概念：将编译后得到的一组目标模块，<u>在装入内存时，采用边装入边链接的链接方式</u> ； 也可理解为当发生外部模块调用事件时，<u>装入程序</u>寻找外部目标模块，修改其相对地址并放入内存的过程



> - 📕运行时动态链接概念：<u>将对某些模块的链接推迟到程序执行时</u> ；也可理解为当发现被调用模块未装入内存时，由<u>OS</u>去外部寻找到目标模块将其调入内存并链接到调用者模块上；

### 🤪动态分区分配算法

> - 📕动态分区算法的优缺点:
>   - **首次适应算法**：
>     - 缺点：<u>但可能产生内部碎片</u>；且后续**每一次**都是**从低地址开始检索空闲区，增大系统开销**
>   - **循环首次适应算法**
>     - 缺点：高地址的大分区容易被用完
>     - 优点：空间分配更加均匀，从上一次访问地址开始检索减小开销 
>   - **最佳适应算法**
>     - 优点：能够**保留空间大**的空闲分区
>     - 缺点：①按分区大小递增/递减进行排列，**每一次回收分区后需要重新排列**，**算法开销很大**②<u>留下难以利用的碎片</u>
>   - 最坏适应算法
>     - 优点：减少难以利用的小碎片
>     - 缺点：**每一次回收分区后需要重新排列**，**算法开销很大**
>   - **快速适应分配**：
>     - 优点：==不会对任何分区<u>产生分割</u>==，能够**保留空间大**的空闲分区，不会产生**内部碎片**的同时查询效率还高
>     - 缺点：**算法本身复杂，在回收资源时算法开销大**
>   - **伙伴系统**
>     - 优点：由于对空闲分区进行合并，减少了容量小的分区，**提高了空闲分区的利用率**
>     - 缺点：**回收资源时需要将空闲分区合并**，算法开销较大

### 🤪对换

> 定义：①对换技术是指将**暂时不能运行**的进程或暂时用不上的数据**换出到外存**，以便腾出空间，将**具备运行条件**的进程**换入内存**的一种内存扩充技术。
>
> 分类：②对换可分为以整个进程为**交换单位**的**整体对换**(中级调度为例)，以及以分页分段为单位的**部分对换**(虚拟存储技术为例)。
>
> 实现进程对换的充分条件：③为了实现**进程对换**，系统**必须实现**三方面**的功能**：对对换空间 (对换区)的管理、进程的换入、进程的换出。
>
> 对对换区空间的管理描述
>
> > ①具有对换功能的OS中将**磁盘空间**分为采用**离散分配管理方式**的**文件区**和采用**连续分配管理方式**的**对换区**
> >
> > ②对换区的分配与回收（和动态分区分配是相似的）
> >
> > ③对换区空闲盘块管理中的数据结构：**空闲分区表**每个表目包括两项：**对换区的首址及大小**，分别用盘块号和盘块数表示
>
> ④进程换入/换出的选择依据：换出选择**优先级低**的或**处于阻塞/睡眠状态**的进程。换入选择处于**就绪态**且**已换出到磁盘上时间最久**的进程
>
> ⑤换出/换入过程描述
>
> > ①只能换出非共享数据、首先申请对换区、传送过程未出现错误则回收占用的内存空间、修改进程控制块和内存分配表等数据结构
> >
> > ②是否有足够的内存支持换入、是否有符合条件的进程

~~Ⅰ对换和覆盖的区别~~



~~Ⅱ对换技术和调入/调出技术的主要区别是~~



Ⅲ覆盖技术和虚拟存储技术最本质的不同在于

<u>程序段的最大长度是否受内存容量的限制</u>



<div class="ZD">
<img src="http://82.157.234.157/ForTakeNotes/image-20221207215436104.png" width = "100%" alt="***" />

Ⅳ内存分区管理方式的比较

<div class="ZD">
<img src="http://82.157.234.157/ForTakeNotes/image-20221207221331833.png" width = "100%" alt="***" />















[TOC]

## 🔥非连续分配管理



- [分页存储管理](#分页存储管理)
  
  - 快表机制
    - 快表机制相较于原始地址变换机制的变化
    - 引入前后访问内存的有效时间的变化
  
  - 两级页表
    - [单级页表存在问题](#TQ)
    - 逻辑地址结构/基本术语
    - 地址变换机理
    - 实现细节
  
- [分段存储管理](#分段存储管理)

  - 引入需求
  - 基本特点
  - 分段和分页的对比

- 段页式管理

- 虚拟存储器

  - 引入需求

  - ✨传统存储器管理方式和虚拟存储器的对比

  - 局部性原理描述

  - 特征(理解具体描述)
    - 多次性：
    - 对换性：
    - 虚拟性：

  - 实现方法
    - 硬件支持
    - 软件支持

- [请求分页管理方式](#请求分页管理方式)

  - 硬件支持
    - 请求页表机制
    - 缺页中断机制
    - 地址变换机制
  - [页面置换算法](#页面置换算法)
    - 最佳置换算法OPT
    - 先进先出置换算法FIFO
    - 最近最少未使用置换算法LRU
    - 最少使用置换算法LFU
    - Clock置换算法
      - 简单型
      - 改进型
    - 页面缓冲置换算法
      - 影响页面出入效率因素
        - 页面置换算法
        - 写回磁盘的效率
        - 读入内存的频率

- 请求分段存储管理方式🛒

- 抖动与工作集🛒

- 内存映射文件🛒

  

















```
```

### 🤪分页存储管理

#### 

Ⅰ.页面大小(2^m^)、内存大小(2^n^)、块号、页表项长度、页表长度

> > 可用n位二进制表示逻辑地址，根据页面大小，选择**用m位二进制表示页内偏移量** ;  同时也有一条重要的信息：==页面大小 <-->页面偏移量->逻辑地址结构==
>>
> > 页表项长度指每个页表项占多大的存储空间，页表长度指该页表总得有多少个页表项
> 

```
```

#### ==Ⅱ.基本地址变换机构==

> 1.**进程未执行**时，页表的始址和页表的长度放在进程控制块PCB中，当**被调度时**内核会将其放入**页表寄存器PTR**中
>
> 2.知晓如何**描述逻辑地址到物理地址的变换过程**
>
> > 进程被调度时，进程切换相关的内核程序就会把进程的运行环境恢复，并把存储在PCB中的始址和页表长度信息放到PTR中 ；
>
> > **根据逻辑地址计算页号和页内偏移量**：分页地址变换机构将逻辑地址分为页号和页内地址两部分
>
> > **判断是否越界**：比较页号和页内长度，若大于则出现越界错误进而被系统中断
> >
> > **访存查询页表（慢表）、块**：由于页表项大小相等，始址和页表项长度、页号得出页表项在页表中的位置，进而得出块号 ...根据简单滴乘法运算（块号*页面大小）得出物理地址
> >
> > > <div class="ZD">
> > > <img src="http://82.157.234.157/ForTakeNotes/image-20221107090901560.png" width = "100%" alt="***" />





```
```

#### ==Ⅲ.具有快表的地址变换机构==

> 1.**工作原理**
>
> 快表当中存有副本可快速拼接形成物理地址，否则需要访存查慢表同时将对应页表项的副本拷贝到快表当中，倘若快表置满还需根据置换算法换入换出页表项
>
> <div class="ZD">
> <img src="http://82.157.234.157/ForTakeNotes/image-20221107084352225.png" width = "100%" alt="***" />
>
> 
>
> 
>
> 2.**支持快表和慢表同时查找**
>
> <div class="ZD">
> <img src="http://82.157.234.157/ForTakeNotes/image-20221107085219444.png" width = "100%" alt="***" />
>
> 
>
> 
>
> 3.**局部性原理**
>
> **时间局部性**：如果执行循环程序中的某条指令，那么不久后该指令很有可能再次执行（存储该指令的内存块会被频繁访问）
>
> **空间局部性**：一旦程序访问了某个存储单元，不久后其附近的存储单元也可能被访问（内存当中连续存放的数据）
>
> > 基于局部性原理，**很可能连续多次查询的都是同一个页表项**,这也是为什么TLB当中**只存储页表中的一部分就可以提升系统效能的原因**

```
```

#### ==Ⅳ.两级页表==

1.[单级页表存在的问题](#TQ)

2.多级页表下地址变换的机理

> ①按照地址结构将逻辑地址拆分成三部分
>
> ②从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置
> 
> ③根据二级页号查表找到最终想访问的内存块号
>
> ④结合页内偏移量得出最终物理地址



3.**注意细节**：各级页表的大小不能超过一个页面/多级页表的访存次数分析

<div class="ZD">
<img src="http://82.157.234.157/ForTakeNotes/image-20221107100759297.png" width = "100%" alt="***" />









#### 答疑区





❓页表项大小计算？是否可能产生内部碎片？如何解决？

> 1.先根据页面大小或内存块大小 得出内存块数量，进一步推出页表项当中表示块号至少要占多少个比特位 ，但因为**计算机分配存储空间是以字节为单位分配**，故需要用字节来表示这些比特位
>
> 2.倘若页表项大小不为2的整数幂，可能在计算过程中产生**余数即内部碎片**；如果**想要一个页框存储下整个页表**，那应该保证页框、页表项大小为2的整数幂，故可以选择增大页表项大小。
>
> 3.总结：**实际应用中通常使一个页框恰好能放入整数个页表项，且为了方便查询页表项，页表项一般是放在连续的内存块中的**
>
> > <div class="ZD">
> > <img src="http://82.157.234.157/ForTakeNotes/image-20221107072449634.png" width = "100%" alt="***" />
> >
> > 



❓页号是否占用空间？指定页表项的位置该如何得知？指定页表项对应的块号位置又是怎么得出的呢？

> ①页表项连续存放（类比数组），因此==页号可以是隐含的，不占存储空间==
>
> ②通过页表在内存中的起始地址X，直接计算
>
> ③对应块号位置直接根据  (块大小*块号) 得出



❓实现**地址变换具体步骤**？（已知逻辑地址A）

> 确定A对应的[页号，页内偏移量]
>
> 找到P号页面在内存中的起始地址（查页表）
>
> 确定逻辑地址A的页内偏移量W
>
> > <div class="ZD">
> > <img src="http://82.157.234.157/ForTakeNotes/image-20221106204435635.png" width = "100%" alt="***" />
> >
> > 



❓为什么页面大小**刚好是2的整数幂**？

> 计算机内部，地址是用二进制表示的，**根据计算机能够通过拼接块号和偏移量的二进制，省去计算始址的时间，快速得出物理地址。**
>
> 如果页面大小不是2的整数幂，那么需要根据公式做除法运算得出页号和页内偏移量，同样页面在内存中的起始地址需要用公式得出 ；一定程度上降低了效率。
>
> > <div class="ZD">
> > <img src="http://82.157.234.157/ForTakeNotes/image-20221106211343759.png" width = "100%" alt="***" />
> >
> > 



❓为什么页式管理中地址是一维的？

> 根据唯一给定的逻辑地址，系统会自动算出页号、偏移量俩部分，**不需要显式给出其它信息**	

❓为什么页面大小要适中？

> ①**页面太小**会导致页表项过多，页表过长占用大量内存；同时也会增加硬件地址转换的开销，降低换入/换出的效率
>
> ②**页面过大**会导致页内碎片增多，降低内存的利用率



❓<span id="TQ">**单级页表存在的问题？如何解决？？**</span>

> ①倘如程序很大，其对应的**页表项也很多**，由于页表必须连续存放，内存存储整个页表**需要消耗一大片连续的内存空间** ，进而**失去离散存储的优势**
>
> ②同时根据**局部性原理**，进程一段时间内只需要访问几个页面就可以正常运行。因此**没必要让整个页表常驻内存！**
>
> 
>
> > ❗解决方案
>
> > ①只将当前需要的**部分页表项调入内存**，其余页表项仍驻留在磁盘上，需要时再调入
> >
> > ②**对于页表所需的内存空间，采用离散分配方式**进行管理
> >
> > 按每个页面能够存储的最多页表项 将页表分组 ，并为离散分配的页表建立**页目录表**以保证页表中每一个页表项原有的先后顺序（模仿将程序分组并一一离散地存放进内存的思想）
> >
> > <div class="ZD">
> > <img src="http://82.157.234.157/ForTakeNotes/image-20221107094447738.png" width = "100%" alt="***" />
> >
> > 







返回[知识框架](#非续知识框架)

```
```

### 🤪分段存储管理

#### 

#### Ⅰ.基本术语

①**大致定义**：按照**程序自身的** **逻辑功能模块划分**为若干个段，段名由用户自行定义，方便于用户编程



②**分配规则**：是以段为单位进行分配，每个段在内存空间中占据连续空间，各段间可以不相邻



③分段的逻辑地址由段号（段名）和段内地址（偏移量）组成 ：前者表示进程最多能分为几个段，后者决定段的最大长度



④**段表以及段表项大小**：



由于每一个段的长度不一致，其在内存中的始址不便于计算，需要特设数据项记录始址 。

<div class="ZD">
<img src="http://82.157.234.157/ForTakeNotes/image-20221107104040327.png" width = "100%" alt="***" />



> ```
>```



⑤地址变换机理：



> **唯一和分页地址变换机制不同的是 分段需要比较两次**
>
> <div class="ZD">
> <img src="http://82.157.234.157/ForTakeNotes/image-20221107105433784.png" width = "100%" alt="***" />
>
> 
>
> ```
> 
> ```



⑥引入满足了用户哪个方面的需要：



> 方便编程、动态增长、动态链接、信息共享、信息保护
>
> ```
> ```



#### ⭐Ⅱ**你看看隔壁家孩子是怎么🐏的**：



1.分页的用户进程**地址空间是一维**的，而分段在...是二维的，因为**标识一个地址**时需要给出段名和段内地址：另外段名、段内地址的给出体现在用户显式提供的汇编语言指令当中。

2.**页的大小固定由系统决定**，段的长度不定，决定于用户编写的程序

3.访问过程中分段管理系统分别对**段号和段长**进行两次比较检查

4.页是**信息的物理单位**，**主要目的**在于实现**离散分配**，提高内存**利用率** ，**对用户是不可见**的； 段是信息的**逻辑单位**，主要目的在于**满足用户**的需要，对用户是**可见的**。

<div class="ZD">
<img src="http://82.157.234.157/ForTakeNotes/image-20221107110647075.png" width = "100%" alt="***" />



<div class="ZD">
<img src="http://82.157.234.157/ForTakeNotes/image-20221207215141871.png" width = "100%" alt="***" />







#### 答疑区



❓分段存储管理方式更符合用户哪些方面的需要



> ①方便编程
>
> ②信息共享、信息保护
>
> ③动态增长(数据段动态增长)、动态链接(运行过程中将目标程序调入内存并进行链接)



❓分段更容易实现信息的共享和保护如何体现？



> **可重入代码**指允许多个进程同时访问，但不允许任何进程对它进行修改的代码
>
> 如果想要某一个功能段(比如用来判断缓冲区是否可访问)被多个进**程共享访问，只需让各个进程的某一个段表项指向同一个段即可**
>
> <div class="ZD">
> <img src="http://82.157.234.157/ForTakeNotes/image-20221107111352806.png" width = "100%" alt="***" />
>
> 
>
> 分页不方便于共享的原因是**同一个页面中** **可能同时存在可共享和不可共享的代码**，其**并不是按逻辑模块划分**的，故很难实现共享和保护
>
> <div class="ZD">
> <img src="http://82.157.234.157/ForTakeNotes/image-20221107111836663.png" width = "100%" alt="***" />
>
> 









返回[知识框架](#非续知识框架)

```
```

### 🤪内存空间扩充技术





#### *Ⅰ虚拟内存的引入/定义*



引入：有的作业很大或者是有大量作业要求运行而内存容量不够大。

> 常规存储器管理方式的特征:
>
> > ①**一次性：**在传统的存储管理方式中**要求作业必须一次性全部装入内存后才能运行**，这致使大作业无法运行或无法容纳大量作业，导致多道程序并发度下降
>>
> > ②**驻留性：**一旦作业被装入内存，就会**一直保留到执行结束**；事实上，只需要访问作业的部分数据即可正常运行，这势必造成**内存资源的浪费**
> 
> 
> 
> 虚拟存储器的特征及定义：
> 
> 
> 
> > <u>工作情况</u>：**基于局部性原理**，在程序装入时，装入可以用到的部分；由操作系统负责对页面的调入(缺页)调出(内存占满) ，以至于从逻辑上扩充了内存的容量；虚存的运用**基于离散分配**的管理基础上，因为连续存储需要保证程序在内存中一直是连续存储的。
> >
> > <u>定义</u>：指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统
> >
> > <u>特征</u>(**注意和常规存储器进行比较**)：
> >
> > > ①**多次性**：一个作业中的程序和数据允许分成多次调入内存，即只需将**当前要运行的部分程序和数据** **装入内存**即可开始运行。
> > >
> > > ②**对换性**：作业**无须**一直**常驻在内存**，允许在**运行过程中**进行**换入换出**。
> > >
> > > ③**虚拟性**：从逻辑上扩充内存容量。
> 
> 
> 
> 虚拟存储器的实现方法：



#### Ⅱ<span id="请求分页管理方式">**请求分页管理方式**</span>



①页表机制

外存地址、修改位、状态位、访问字段

> 字段说明：为**实现“请求调页”**，根据页表能够已知每个页面调入与否(**状态位**)，以及它们在外存中的存放位置(外存地址) ；当空间不够时，要**实现"页面置换"**，操作系统需要通过特定指标供置换算法参考并决定换出(**访问字段**)



②**缺页中断机制**：



> ==具体步骤为==：                                                                                                                                      **壹**：访问的页面**不在内存中时**，**产生缺页中断**并交由**操作系统**的**缺页中断处理程序**处理 ，中断处理程序涉及**IO操作**，将页面从外存**调入内存**；
>
> **贰**：此时发生缺页的进程因等待IO操作完成而被阻塞，待调页完成后被唤醒
>
> **叁**：①**如果内存中有空闲块**，为进程分配一个空闲块，并**修改**表中对应的**页表项**。②**如果没有空闲块	；**则由页面置换算法**淘汰页面**，**被修改过**的淘汰的页面**需将其写回外存**覆盖原数据 ~~紧接着让调入的页表占用空出来的页表项，并**修改页表项数据**和快表~~



③==缺页中断定义==：





> 缺页中断属于**故障型的内中断**，可被相应的故障处理程序修复；
>
> 另外一条指令执行期间可能访问多个存储单元，倘若存在多个存储单元未被调入内存，即**可能产生多次缺页中断**



 ④**地址变换机制**：



> ==具体过程==：
>
> ①找到页表项需要检查页面是否在内存中
>
> ②若不在内存中，需要由OS启动IO操作将页面调入内存
> 
> ③若内存已满，需要利用置换算法选择一页换出
> 
> ④页面调入内存后，需要修改页表项数据



⑤==🐟注意点==：



> One：**快表中存有的页面一定是在内存中的（或者说块表命中，一定没有缺页）**，若某个页面被换出外存，则快表中的相应表项也要删除，否则会访问错误
>
> Two：🔥**只有“写指令”才需要修改”修改位“**。一般**只需要修改快表**中的对应表项数据，只有要将**快表项删除时**才需要将该**快表项复制回慢表**中。这样**可以减少访存次数**。
>
> Three：**换入换出页面**都需要**启动IO操作**，倘若俩操作过于频繁会增大系统开销
> 
> Four：页面调入内存后，需要**修改慢表**，同时也需要**将表项复制到快表中**（即下一次访问必定命中）

<div class="ZD">
<img src="http://82.157.234.157/ForTakeNotes/image-20230207193150446.png" width = "100%" alt="***" />





#### Ⅲ <span id="页面置换算法">**页面置换算法**</span>



最佳置换算法：

> ①工作机理OPT：在未来最长时间内不再被访问的页面
>
> ②优缺点：保证了最低的缺页率，但执行过程中根本无法预判接下来的访问序列，所有OPT无法实现





先进先出算法FIFO：



> ①实现方式：把调入内存的页面根据调入先后顺序排列成队列，换出时挑队头下手
>
> ②优缺点：当为**进程分配的物理块数增大**时，出现**缺页次数不减反增的现象**,即Belady异常（FIFO特有现象） ；因为先进入的页面可能被经常访问，故性能较差



#####  🛫<span id="LRU" style="color:red;font-size:16px;background:pink">最近最久未使用置换算法LRU:</span>



~~实现机理：淘汰最近最久未使用的页面~~



①优缺点：算法性能接近最佳算法，但需要硬件支持 开销大



②📕算法描述：考虑到FIFO存在**页面调入先后不能反映页面使用情况**的问题，LRU根据页面调入内存后的使用情况做出决策，即根据各页以前的使用情况 ，是否予以淘汰



③实现机理：



> 为记录某进程在内存中各页的使用情况，须为<u>每个在内存中的页面配置一个**移位寄存器**(表现为R=R~n-1~...R~0~)</u>
>
> 当进程访问物理块时，相应寄存器的R~n-1~位置成1;此时定时信号将<u>每隔一段时间将寄存器右移一位</u>，<u>具有最小数值的寄存器</u>所对应的页面就是最近最久未使用的页面
>
> > <div class="ZD">
> > <img src="http://82.157.234.157/ForTakeNotes/image-20221117190500599.png" width = "100%" alt="***" />
> >
> > 
>
> 
>
> 利用特殊的栈保存当前使用的各个页面的页面号，**正在访问的页面**会被**从栈中移出 **并**压入栈顶**；**栈底**则是**最近最久未使用页面的页面号**



时钟置换算法Clock：





①实现机理：将内存中的页面通过链接指针链接成一个循环队列，从头开始访问，对页表项中访问位为0的页面换出或将其访问位 置为0



②细节：1.换入页面后，访问指针指向下一个位置，2.但倘若页面已经存在在内存中，访问指针不移动 ；两者都需改变访问位值

> <div class="ZD">
> <img src="http://82.157.234.157/ForTakeNotes/2022118102253.png" width = "100%" alt="***" />
>
> 



改进型的时钟置换算法：



①实现机理：在基本时钟算法上 **在其它条件相同时，优先淘汰没有修改过的页面**

②算法规则描述：

> 第一轮淘汰最近没被访问且没被修改的页面，但扫描期间不修改访问位
>
> 第二轮淘汰最近没被访问但被修改过的页面，所有扫描过的页面的访问位会置为0
>
> 第三轮淘汰最近访问过但没修改过的页面，期间不修改任何标志位
>
> 第四轮淘汰最近访问过且修改过的页面。
>
> 优缺点：相较于普通时钟算法，减少IO操作次数，但算法开销很大



#####  🛫<span id="页面缓冲算法PBA" style="color:red;font-size:16px;background:pink">页面缓冲算法PBA</span>



概述：采用PBA的系统，内存分配策略上采用可变分配~~局部置换~~方式，系统为显著地降低页面换进换出的频率，在内存中设置了两个链表:

Ⅰ**空闲页面链表**：①系统可将手头上的空闲物理块，分配给频繁发生缺页的进程；②当未被修改的页要换出时，实际上它并未被换出到外存，而是将其所在物理块挂在空闲链表的末尾③ <u>未被修改的页仍旧可以某些进程被反复利用，这样免去了磁盘IO操作，减少了页面换进的开销</u>

Ⅱ**修改页面链表**：①对于被修改过的页面，系统暂不将它们写回磁盘，而是挂在该链表的末尾，<u>仅当页面数量达到一定值时，再将它们一起写回磁盘</u>②这么做的目的**在于减少磁盘IO的操作次数，降低已修改页面换出的开销**

主要特点：

①（看算法名称缺置换两字）由于页面换入换出的频率大幅度减少，磁盘IO操作次数减少

②可采用FIFO置换策略算法，因为它不需要特殊硬件支持，实现简单。











#### 答疑区

❓普通中断和缺页中断的区别

①缺页中断在**指令执行期间** <u>产生和处理中断信号</u>；CPU都是在一条指令执行完后，才检查是否有中断请求到达

②**一条指令**在**执行期间**可能产生**多次缺页中断**

```
教科书上的说明
```

①**中断产生的时刻不同**：缺页中断是在执行一条指令中间时产生的中断，并立即转去处理；而一般中断则是在一条指令执行完毕后，当硬件中断装置发现有中断请求时才去响应和处理。

②**处理完毕后的归属不同**：缺页中断处理完后，仍**返回到原指令**去重新执行，因为那条指令并未执行；而一般中断则是或**返回**到**被中断进程的下一条指令**去执行，因为上一条指令已经执行完了，或重新调度，去执行别的进程程序。

```
王道计组书中的说明
```

①缺页等**异常事件**是由**特定指令**在**执行过程中**产生的，而中断**与任何指令无关联**，也不阻止任何指令的完成

②异常的检测**由CPU自身完成**，对于中断，CPU必须通过**中断请求线**获取**中断源**的信息

❓中断处理程序的处理过程分为几步：

①测定是否有未响应的中断信号

②保护被中断的CPU环境(保存断点和程序状态)

③识别中断并转入对应的设备处理程序

④恢复CPU现场并退出中断，(根据对多中断源的处理方式，决定是否立即)返回被中断的进程

❓如何设计实现一个性能优异的请求分页系统

首先从三个方面着手：

①页面置换算法

②写回磁盘的频率

③读入内存的频率

> 另外参考[工作集](#工作集)工作原理
>
> 如果能够预知程序在某段时间间隔内要访问哪些页面，并将它们调入内存，将会大大降低缺页率，从而提高处理机的利用率;
>
> 可惜没有如果。考虑到程序只需少量的几页在内存便可运行，可<u>将程序的所有工作集装入内存中</u>，并和置换算法那样，用程序的过去某段时间内的行为作为**程序在将来某段时间内行为的<u>近似</u>**

相较于基础分页存储管理，具有快表机制的请求分页管理方式的访存有效时间计算有何不同

①被访问页在内存中，对应页表项在快表中

②被访问页在内存中，对应页表项不在快表中

③被访问页不在内存中

返回[知识框架](#非续知识框架)

```
```



### 🥵页面分配、置换策略



#### Ⅰ**页面分配、置换策略**



预备知识：

> ①驻留集：指请求分页存储中给进程分配的物理块的集合，采用虚拟存储技术的系统中，驻留集大小一般小于进程的总大小 ；
>
> ②采用**固定分配和可变分配方式**： **前者**指**运行过程中**进程**分配固定数目**的物理块，后者在运行期间的物理块数目**可变动**；驻留集**过小**会导致缺页频繁，**过大**导致内存中驻留的进程数量降低，致使**多道程序并发度下降**，可能**造成CPU空闲或其它资源空闲**的情况，致使**资源利用率降低**(🤔)
> 
> ③采用**局部置换或全局置换方式**：**前者**指进程发生缺页时，**只能在分配给自己的内存空间里进行置换**而不允许从其它进程去获取新的物理块，**后者**可**将操作系统保留的空闲物理块**或未锁定的物理块分配给该缺页进程，或将其它进程的物理块置换至外存



==内存分配策略==：



①**可变分配全局置换**：



> 机理：当某进程发生缺页时，将OS所保留的空闲物理块分配给该进程；仅当空闲物理块用完时，系统才会选择一个未锁定的页面（可能是任何一个进程中的页）调出，因此被选中的进程物理块减少缺页率增加



②**可变分配局部置换**： 



> 系统会根据进程的缺页率 合理动态控制进程的物理块数量
>
> 



==页面调入策略==：





> -----------------------------------==何时调入页面==-------------------------------
>
> 
>
> ①**预调页策略：**基于局部性原理，一次性调入若干个可能被访问的页面，主要用于进程的首次调入即运行前。
>
> ②请求调页策略：进程在运行期间发生缺页时才将所缺页调入，每次调页需要IO操作，开销大
>
> -----------------------------------==何处调入页面==-------------------------------
>
> 
>
> ①**外存有足够的对换区空间**，页面的**调入调出**存取位置都是对换区，且运行前需要将进程的所需文件拷贝到对换区。
>
> ②**外存没有足够的对换区空间**，不会被修改的文件直接从文件区调入，且由于不会被修改，该文件也无需重写回磁盘当中，每次调入都需要从文件区获取。会被修改的文件，其有关页面的调入调出存取位置都是对换区
>
> ③**UNIX方式**，未运行的页面会从文件区调入，曾经运行的进程调入调出都发生在对换区。



#### Ⅱ **抖动现象**：



**定义和发生原因**：一段时间内，存在页面频繁地调入调出即反复横跳，这种现象称为抖动，**产生的主要原因**是**同时在系统中运行的进程太多，分配给每一个进程的物理块少，不满足进程正常运行的要求，致使进程频繁缺页**（进程**频繁访问的页面数**大于所分配的物理块数）；后果就是~~系统会采用大量时间进行调入调出操作~~对**磁盘的有效访问时间急剧增加**，而每个进程的大部分时间都用于页面的换进/换出，实际的有效工作执行时间很少，从而导致**处理机的利用率下降趋于0**的情况(可能考题会比较抽象，直接上任务管理器图表，根据CPU和磁盘利用率使用情况，试问发生什么了🤣)



<center class="half">
<img src="http://82.157.234.157/ForTakeNotes/20221181200%E6%98%9F%E7%88%B7.gif" width = "50%" alt="***" align=left />
<img src="http://82.157.234.157/ForTakeNotes/20221181200%E6%98%9F%E7%88%B7.gif" width = "50%"  alt="***" align=right />

<center>









**抖动的预防方法**：

①采用局部置换策略：

②**把<span id="工作集">工作集</span>算法融入到处理机调度中**：

基于局部性原理，根据进程近期访问的页面集合设计一种算法选择一个不在工作集中的页面进行淘汰 

系统可以检测工作集的最大大小，决定要给这个进程分配多少个物理块

> <div class="ZD">
> <img src="http://82.157.234.157/ForTakeNotes/image-20221108121509158.png" width = "100%" alt="***" />
>
> 



③利用”L=S“准则调节缺页率



④先择暂停的进程



### ✨(New!)内存映射文件

①**传统的文件访问方式**：

文件需要分组并离散存储在外存中(类似于分页管理存储)，进程欲访问或操作指定数据，则需要使用各种系统调用原语将指定文件块调入/调出 进程的**虚拟地址空间**.

<div class="ZD">
<img src="http://82.157.234.157/ForTakeNotes/image-20221108123352591.png" width = "100%" alt="***" />



②**内存映射文件访问方式：**

**读写操作更方便：**使用mmap系统调用返回指向整个文件的起始位置的**指针**，可以通过指针**访问内存的方式**访问/操作文件任意一处的数据。**最重要的是**文件的所有数据并没有真正调入储存，而是通过系统自动地按缺页异常处理，将**需要访问的数据调入**储存 ；即无需程序员手动使用Read系统调用一一调入，**整个文件读写过程由系统自动完成** ；**注意**的是进程**关闭文件时**才能将被修改的数据写回磁盘，OS负责解除内存映射

​	

>  ①**<span id="具备共享性">具备共享性</span>：**多个进程可以映射同一个文件，实现数据共享
>
>  <div class="ZD">
>  <img src="http://82.157.234.157/ForTakeNotes/image-20221108124553905.png" width = "100%" alt="***" />
>
>  
>
>  ②**各进程的虚拟地址空间是相互独立的**，但它们可以通过将各自虚拟地址空间中的**内核区页面**(包含数据区和代码区)映射到内存中的**同一个物理页框**里
>
>  <div class="ZD">
>  <img src="http://82.157.234.157/ForTakeNotes/image-20221111163453047.png" width = "100%" alt="***" />
>
>  
>
>  ③代码区是指令的集合，CPU会解析指令的虚拟地址，以此确定访存内容位置

## 🤔存储管理及大题解构（和计组衔接）

大概题型：

①一级页表+TLB+请求分页 ②二级页表+TLB+请求分页

③基于虚拟内存的地址转化过程的剖析





知识点（PDF在本文件目录下）：

> 概念推演：
>
> > 比如根据页号/页表索引 + 页表项长度 ==> 二级页表的大小
> >
> > 根据PTR中的<u>页目录表的起始物理地址</u> 和 <u>页目录表的页号</u> =>  页目录表项的物理地址，得到页目录项的具体内容，由其得到**下一级页表存放的页框号 + 已知的页号**得到页表项的物理地址 ，从而得知页表项的具体内容...
> >
> > 注意：根据36位系统(按字节编址) ->虚拟地址36bit(除页内偏移量外称为虚拟页号)
>
> 地址变换过程：注意快表中是以<u>整个虚拟页号</u>判断是否命中的，而访问慢表时可能存在多级页表需要<u>将虚拟页号拆分为一级和二级页表</u> ，且可能发生缺页
>
> [进程通信实质](#具备共享性)
>
> 回顾：**进程未执行**时，页表的始址和页表的长度放在进程控制块PCB中，当**被调度时**内核会将其放入**页表寄存器PTR**中

①不同的进程可以共享同一块页框，同一个进程可以将低地址内核数据区的内容转移到用户的数据区

②CPU分析访存指令，通过将其虚拟地址转换为物理地址达成访存目的
