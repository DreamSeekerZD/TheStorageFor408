[TOC]

<font face="STCAIYUN" size ="6">Author：DreamSeekerZD</font>



### 🌆控制器的功能和工作原理

---

#### 🛫硬布线控制器设计

本质：根据<font color="red" size="3.5">指令操作码、目前的机器周期、节拍信号、机器状态条件(PSW)</font>，即可确定该节拍下应该发出哪些微命令。

![image-20230504205845106](E:\每日三省吾身\imgs\image-20230504205845106.png)

①微操作和微命令的概述

通过若干个微操作序列完成每一个机器周期应处理的事务，每个机器周期由若干个时钟周期(节拍)组成，CU会在<u>每个节拍内</u>发出一个微命令(与微操作相对应的控制信号)，**每个微命令和微操作是一一对应的**。

<u>微操作</u>更多的是在描述我们要做的一个细分的工作，这个工作要完成一个什么样的功能，而<u>微命令指的是</u>要完成这个细分的工作所需要发出的、一些有效的**控制信号**。

②同一节拍内，相容的微操作的由来

采用<u>**专用的数据通路**</u>可使多个寄存器之间的数据并行流通，故每个节拍内可并行完成互不冲突的微操作。

③采用定长机器周期策略

不同的指令，它在执行周期所需要的节拍数可能各不相同，采用**定长机器周期策略** ，可使电路设计更加简单，即每个机器周期包含的节拍数均相同，个别时钟周期(节拍)内可以什么都不做。

通常我们会以可能出现的最大的节拍数作为参考，作为定长的机器周期。

访存的速度极慢，涉及到访存的指令的执行，它所需要的节拍数就是有**可能出现的最大的节拍数**，因此我们会**以访存所需要的节拍数作为参考，来确定一个定长的机器周期**。

④微操作复用

<u>**同一个微操作可能在不同的指令的不同阶段被使用**</u>。比如把PC送进mar这个微操作，在所有的指令的取指阶段，肯定都会使用，把它送到mdr这个微操作在很多指令的不同周期内也会被重复的使用到。

-----

![image-20230504210306971](E:\每日三省吾身\imgs\image-20230504210306971.png)

<u>因为不同的指令，在执行阶段所需要做的微操作序列是不一样的</u>

①n位操作码对应2^n种状态 （2^n个不同的指令），CU通过译码器发来的高电平信号，<u>具体判断当前执行的是哪一条指令。</u>

②通过接收集成在CU内部的寄存器的信息，<u>判断目前处于哪一个机器周期</u>。

③节拍信号是通过一个节拍发生器给出的，根据这些线哪根线输入了高电平信号，<u>判断出当前处于这个机器周期内的第几个节拍</u>。

如上图所示，假定采用定长机器周期，每一个机器周期会包含m+1个节拍。从t0到tm总共m+1个节拍，这些节拍信号是循环的，如果此时已经到达了当前这个机器周期的最后一个节拍，发出这个节拍信号之后，接下来如果再接收到下一个脉冲信号，那么下一个节拍信号又会回到t0，那这也就**意味着我们进入了下一个机器周期**。

④ 来自**执行单元**的反馈信息

<font face="宋体">🌈了解即可</font>⑤根据上述各个因素产生的**逻辑表达式**(或称为每个微操作命令的逻辑表达式)，选择合适的硬件(与非门等)，设计相应的数字电路，选择向C~0~\~C~k~发出高电平，输出控制信号。详见具体设计步骤中的<font color="orange">组合逻辑电路设计</font>

 

#### 🛫具体设计步骤

![image-20230504213454240](E:\每日三省吾身\imgs\image-20230504213454240.png)

①第三步指将微操作序列分别安排到不同的节拍内，具体工作包括选择哪些微操作安排在同一节拍内，哪些微操作的执行顺序在前在后。

##### 

![image-20230504214652167](E:\每日三省吾身\imgs\image-20230504214652167.png)

①指令执行的过程当中所进行的微操作可能会因为机器状态条件的改变而改变。<font color="green">看绿字行事</font>

②OP(IR)是指指令字的操作码部分 ，Ad(IR)是指指令字的地址码部分。



##### 

![image-20230504215900542](E:\每日三省吾身\imgs\image-20230504215900542.png)

①原则二举🌰:(PC)$\to$MAR 的被控对象是**寄存器**PC而$1\to R$的被控对象是**主存**，故可安排在同一节拍内完成 ，且只要存储器空闲，就可发出$1\to R$微操作对应的微命令

②<font face="宋体" color="red">为什么操作45可放一块而34不能放一块</font>

> CPU内部的寄存器，各个部件之间的数据流通是很快的。所以cu可以并行的发出这(4)(5)两个微操作所对应的微命令，让这两个微操作同时进行。

> 后者原因在于(3)这个操作我们是要**从主存当中读取数据**。而从主存中取得一个数据的用时是比较长的，因此我们**必须使用一个时钟周期**才可以**保证**我们**能够从主存当中读得这个数据**。因此，我们不能把3和4这两步安排在同一个节拍内。

③(采用的定长机器周期)所需要的微操作数较少，可将所有的微操作都安排在最后一个节拍进行。

 ##### 组合逻辑设计

![image-20230504221313229](E:\每日三省吾身\imgs\image-20230504221313229.png)



![image-20230504221350574](E:\每日三省吾身\imgs\image-20230504221350574.png)



① 列出操作时间表

每一个节拍内所有的指令有可能使用到的微操作都把它罗列到了一起。然后再用标一的这种方式来标记出每一条指令，有可能用到的微操作是哪几个。

②设计微操作命令对应的逻辑表达式

![image-20230504221610494](E:\每日三省吾身\imgs\image-20230504221610494.png)

(ノ｀Д)ノ⚡③画出电路图

```
```

#### 🛫细🔒特点

①所以由于硬部件控制器纯硬件实现的，这种控制器它的实现和设计和指令的种类是直接挂钩的，因此通常来说这种纯硬件的控制器。会用于risk，也就是精简指令集系统，精简指令集系统意味着啊，这个系统所能支持的指令条数不会特别多。而对于sis复杂指令集系统有可能出现好几百条指令，那这种系统如果用单纯的硬部线控制器，这种设计方式来设计显然会非常的困难，复杂度很高很高。所以，复杂指令集系统通常会采用我们下一小节要介绍的微程序控制器

②对于一个硬部线控制器来说，如果我们要扩充一条新的指令，那么是不是就意味着我们这个控制器的设计都就需要大改？硬件电路需要改动的地方非常非常多，所以要扩充指令是很困难的，就以刚才我们呃所列出的这条指令为例。与这样的一个微操作相对应的呃，电路里边你看就有可能接入各种各样的指令的一个一个信息，那如果说我们还要再增加一条指令，万一那条指令也需要在某些时候。用到这个微操作，那是不是就意味着我们之前设计的这个电路又得作废，又得重新设计

③由于我们是采用纯硬件，纯电路的方式来实现控制的，所以采用硬部线控制器实现了CPU。执行指令的速度是非常快的

微操作控制信号的一个产生速度会非常快



```
```

### 🌆微程序的设计

#### 🛫设计思路

![image-20230505194134676](E:\每日三省吾身\imgs\image-20230505194134676.png)

①

模拟指令执行的处理方式，处理微操作序列。**微程序**由一系列微指令组成，每条微指令可对应多个微操作，不同的机器指令所需要完成的这些微操作序列是不一样的，因此**不同的机器指令所对应的微指令序列也不一样**。

```
```

##### ②机器指令和微指令的工作内容以及联系

机器指令是对程序的执行步骤的一个描述，而微指令是对某一条具体的机器指令执行步骤的一个具体描述，即每一个步骤需要完成哪些微操作。

```
```

##### ③微指令和微操作等对应关系

微操作是强调我们要做什么，而微命令是强调我们要完成这个微操作，需要发出哪一个控制信号。**一条微指令**有可能会并行的完成两个或者**多个微操作**，**一个微程序**由**若干个微指令**序列组成，**微程序**和**机器指令**也**是一一对应的**。

```
```

④

采用存储程序思想，在CPU崭新出厂前，将所有的机器指令所对应的微程序都存放到特殊的存储器"控制器存储器"当中。

```
```

##### ⑤微指令的基本格式

每条微指令的**操作控制**字段会利用若干个bit表示当前微指令所对应的微操作是哪几个。微指令序列存储在**控制器内部**的**一个特殊存储器**当中，顺序控制字段利用若干个bit指明下一条微指令的地址

#### 🛫CU的基本结构

![image-20230505195318665](E:\每日三省吾身\imgs\image-20230505195318665.png)

①控制存储器CM

ROM读取的速度比RAM快，另外ROM是一种非易失性的存储芯片，这就意味着CPU断电之后，这个ROM芯片当中存储的这些微程序是不会丢失的。那显然，每一条机器指令所对应的这个微程序，或者说它所对应的这些微指令序列，应该是由CPU的厂商负责设计。并且需要在CPU出厂之前把这个ROM里边的微程序数据全部把它给写好。

```
```

②套娃地址寄存器CMAR和微指令寄存器CMDR

CMAR是PC和MAR的一个功能结合体， 

CPU中的mar给出的这些地址信息是不是需要通过一个译码器的处理才可以选中主存的某一个存储单元？所以对于CU内部的CMAR来说，同样的也需要把这个地址信息送给一个地址译码器，然后通过地址译码器。把地址转换成CM当中对应存储单元的一个存取控制信号。

```
```

##### ③微地址形成部件的作用

外部的一条机器指令，它会被取到ir指令寄存器当中，根据不同的机器指令，它所对应的微指令序列，也就是它所对应的微程序是不一样的，因此，我们需要**根据这条机器指令的操作码来确定它所对应的微程序的起始地址**是什么。根据机器指令的操作码来确定这个机器指令，它所对应的微指令序列的一个首地址。

```
```

④顺序逻辑

用于控制微指令的执行顺序的。因为微指令序列不一定是一条一条顺序的往下执行，如果说有中断发生或者没有中断发生的时候，这个微指令序列的执行次序肯定需要进行一些调整的。

```
```

#### 🛫CU的工作原理

![image-20230505201553148](E:\每日三省吾身\imgs\image-20230505201553148.png)

①

~~不同机器指令的不同机器周期所要执行的微操作序列需要发出的控制信号是相同的~~任何机器指令的取指令操作是相同的，因此取指令操作的微命令可统一编成微程序。故其它的操作同样也可统一编成微程序。

②

![image-20230505203040232](E:\每日三省吾身\imgs\image-20230505203040232.png)

<u>假定某个指令系统当中有n条机器指令</u>，那么这n条机器指令它们所对应的执行周期的微程序段是不是都不一样？因此，我们就需要设计n个微程序来分别描述这n条机器指令的执行周期所需要做的事情，那另外还需要再加上一个公用的取指周期的微程序，所以在这个系统当中控存里边<font color="redorange">微程序段</font>**的个数至少是n+1个**。**很小的CPU可以不提供间接寻址，也可以不提供中断的功能** 

它并不会认为取指周期的微程序和执行周期的微程序是两个微程序，<u>逻辑上，我们应该**把这两段微程序把它们看作一个整体**</u>，故**一条指令也可对应一个微程序**，<font color="redorange" face="微软雅黑" size="3"><u>微程序的个数可以只有n个</u></font>。

 ![image-20230505202616636](E:\每日三省吾身\imgs\image-20230505202616636.png)

①

程序由一系列的机器指令组成，而微程序由一系列的微指令组成。那微指令序列是对指令具体功能的描述。每一条微指令可能会对应一个或者多个微操作。所以我们可以用微指令来描述指令执行的各个阶段需要完成哪些微操作。

```
```

②

另外主存储器是用来存放机器指令的。而控制器，存储器呃，也就是控存是用来存放微指令序列的。它被集成在控制单元的内部，并且需要注意控存，通常是用ROM来实现的，可以实现按地址寻访。在CPU出厂的时候，厂家会把这个CPU所支持的所有的指令，对应的微程序都给写入到这个ROM芯片当中，也就是写入到控存里边

```
```

③

微命令和微操作是一一对应的，而一条微指令有可能会包含多个微命令，也就是说一条微指令有可能并行的指挥呃，同时完成多个微操作。

它们是一对多的关系，另外微程序又由一系列的微指令来组成，它和微指令也是一对多的关系，而微程序和机器指令。又是一对一的关系，每一条机器指令都会对应一个呃微程序

```
```

④

微指令周期是指从控存CM当中去取出一条微指令，并且执行相应的微操作所需要的时间。总之用于描述微指令的执行速度。



```
```

### 🌆微指令设计

微指令的具体格式如何设计？如何根据微指令发出相应的微命令？

一条微指令可以包含多个微命令(微操作)

#### 🛫指令格式分类

![image-20230505205349319](E:\每日三省吾身\imgs\image-20230505205349319.png)

```
```

#### 🛫水平型微指令的编码方式

利用微指令的操作控制这几个比特位来形成控制信号，设计的目标是要尽可能的保证速度，同时还要尽可能的缩短微指令的字长。

![image-20230505210751150](E:\每日三省吾身\imgs\image-20230505210751150.png)

🌈**直接编码**：**每一个比特位会对应一个具体的微操作**，也就是对应一个微命令，可假定高电平即可发送微操作，<u>如果我们的这条微指令它想要同时的完成这两个微操作</u>，只需要让这条微指令的控制字段第一位和最后一位为一，其他全部为零。

```
```

![image-20230505211317060](E:\每日三省吾身\imgs\image-20230505211317060.png)

🌈**字段直接编码**：可以把这些**互斥微操作**分到同一个段里边，同理可把相容的微操作放到不同的段里边。不同段通过与其对应的译码器，发出与之相对应的控制信号，使得**从属于不同类的微操作同时并行发出**。 其它规则如图所示。

**缺点**在于**通过译码电路发出微命令，因此比直接编码慢**。

```
```

![image-20230505212303382](E:\每日三省吾身\imgs\image-20230505212303382.png)



🌈**字段间接编码方式**：**一个字段所对应的某些微命令，可能需要由另一个字段当中的某些微命令来解释**。<u>而不是靠字段直接译码发出微命令</u>，所以像这一图里边字段二经过译码器译码之后。并不是直接发出这个字段所对应的控制信号，而是会把这个译码器的一个输出信号把它输送给下一级的译码器。然后经过下一级的译码器，再进行一层处理之后，才发出最终的这个控制信号。**每个字段所对应的微命令需要经过至少两次间接的译码才可以得到最终其对应的控制信号。**

缺点如图😀

```
```

#### 🛫微指令的地址形成方式

![image-20230505212623849](E:\每日三省吾身\imgs\image-20230505212623849.png)

①比如CU的工作原理当中，13号指令的下地址是14即直接指出后继微指令的地址。

②比如CU的工作原理当中，2号指令后不一定有间地周期，故需要将**机器指令的操作码部分送给地址形成部件**，<u>由该部件指明与该指令相对应的微程序的起始地址</u>。

③毕竟是PC和MAR的功能结合体，想要**顺序执行一系列的微指令序列**，懂得都懂

④类似于机器指令的jump指令，那么这种转移类的微指令。会指明这个转移方式，也就是要指明判断的条件，满足某些条件的情况下才进行转移，那么接下来微程序执行流的转移地址。**该类微指令也会直接的改变下一条微指令的一个地址**。

⑤测试网络是指它内部的处理电路，当然可抽象理解为顺序逻辑中的标志信息，结合当前微指令的比特信息决定 接下来应该执行的微指令的存放地址。

⑥取指周期所对应的微指令序列是公用的，都是从0地址开始存放，任何一个指令的第一条微指令的地址肯定都是零号地址

![image-20230505214211907](E:\每日三省吾身\imgs\image-20230505214211907.png)

```
```

#### 🛫微程序控制单元的设计

总体步骤和硬布线控制器设计差不多

![image-20230505220511271](E:\每日三省吾身\imgs\image-20230505220511271.png)

①看图找茬之细🔒不同

对于取指周期的第一条微指令来说，我们会固定的把它存放在零号单元里边。所以**第一条要执行的微指令是由硬件自动的给出**的。且接下来要执行的微指令的存放地址包含在当前执行微指令的下地址字段，<u>同时执行完一个微指令之后 ，需要将下地址字段信息送给CMAR</u>(**需要消耗一个节拍**)。

考虑如何转入下一个机器周期？不同指令在执行阶段的微程序各不相同，需要根据当前指令的操作码，来确定该机器指令**下一个机器周期所对应的微程序的起始地址**。注意$微地址形成部件\to CMAR需要消耗一个节拍$

<img src="E:\每日三省吾身\imgs\image-20230505221248374.png" alt="image-20230505221248374" />

在指令的执行周期内，我们同样的列出微操作序列，然后把可以同时并行进行的微操作，把它们进行分组。每一组微操作就会对应一个微指令，而每一个微指令执行结束之后，我们都需要再添加上Ad(CMDR)->CMAR。这个微操作同样会消耗一个节拍。

<img src="E:\每日三省吾身\imgs\image-20230505221610539.png" alt="image-20230505221610539" />

4.编写微指令码点：假定采用直接编码方式，控制码部分每一个比特位对应一个微操作，故微指令都成了01001...的形状，接下来可以将微指令序列存入CM当中，出厂！

```
```

#### 🛫微程序设计的分类

##### 静、动态微程序设计

CPU出厂之后，还有可能会。会被改变这个微指令序列。那改变控存里边的微程序，是不是就意味着我们可以拓展一些新的机器指令？或者也可以优化某一些现有的机器指令，它的一个执行过程。

要实现动态微程序的设计，显然我们应该使用可以擦除的，比如说可以电擦除的ROM芯片。

##### 毫微程序设计

毫微程序是指用毫微指令即更细分的一种套娃指令序列，来解释每一条微指令的执行，所以所谓毫微程序是用来解释微指令的。反正就是更细分，更深一层的套娃就对了，关系就和机器指令和微指令一般。

```
```

#### 🛫硬布线与微程序的比较

想要**对指令系统进行扩充**，比如说想要多支持几条这种机器指令的时候，那么很多情况下我们**不需要修改这个微程序控制器内部的电路**。我们可以**用当前已经有的一些微指令来描述我们想要新添加新扩充的这一条机器指令**就可以了。对于硬部件控制器来说，它的设计是很繁琐的，**想要在硬部线控制器当中增加一条新的指令**，我们**需要重新设计内部的组合逻辑电路**，那显然是很困难的。

所以硬部线控制器通常会用于RISC，也就是精简指令集系统，在精简指令集系统当中。所能支持的机器指令条数通常是比较少，并且是相对固定的。因此，这种指令系统我们采用硬步线控制器，可以使得指令的执行速度更快。好另一个方面，如果是SISC，也就是复杂指令集系统。比如说叉八六架构英特尔的这一系列CPU就基本上都是采用微程序控制器，因为复杂指令集系统所能支持的机器指令种类非常非常多。并且，这些机器指令的种类还有可能经常需要扩充，因此采用微程序控制器可以使得CPU的设计成本更低，随之而来的代价，就是每一条机器指令的执行速度可能会更慢

![image-20230505223028459](E:\每日三省吾身\imgs\image-20230505223028459.png)



```
```

### 🌆指令流水线

**①定义**

**CPU工作原理**就是执行一条一条指令的过程，那指令的执行过程又会被划分为若干个阶段，且**在CPU内部，同一时刻只会有一条指令在执行**。

一条指令它的执行过程可以被分为多个阶段，那么不同的计算机对这个阶段的划分可能会不一样，一条指令在不同的阶段所需要使用到的硬件部件是不一样的。

指令执行的这些机器周期内，每个阶段会**用到的硬件有可能是不一样的，有可能的是冲突的**。

![image-20230506200138755](E:\每日三省吾身\imgs\image-20230506200138755.png)

②执行方式

顺序执行方式(串行执行方式)意味着，一条指令**只有完成了取指、分析、执行(假定被某计算机划分成这仨)这仨阶段的工作之后，才能执行下一条指令**

#### 🛫流水线的表示方式

以下例子均以最理想的状况出现：各阶段花费时间相同，每个阶段结束后能够立即进入下一个阶段。实际运行中，各个指令可能会产生相互制约相互依赖的关系(可参考操作系统的进程同步)，故很难达到理想状态。

①流水线的性能指标

<img src="E:\每日三省吾身\imgs\image-20230506200700048.png" alt="image-20230506200700048" />

**流水线的吞吐率**指的是<u>在单位时间内，流水线完成的任务的数量</u>，对于指令流水线来说，大多数情况下，我们所探讨的吞吐率就是指单位时间内。我们可以完成多少条指令。

**为什么会取Δt=1个时钟周期呢？**一条指令的执行被分为多个阶段，之前所说每一个阶段理论上应该是对应一个机器周期，而一个机器周期有可能包含多个时钟周期，**由于图中的时空图十分的理想化，故一个机器周期内可认为仅有一个时钟周期**。

![image-20230506202236200](E:\每日三省吾身\imgs\image-20230506202236200.png)

②加速比

完成同样的一批任务，**如果不使用流水线和使用流水线，这个时间花销上的比例**。

如果说不使用流水线的话。那么每一条指令的执行会被分为k个阶段，而每个阶段需要Δt这么长的时间....

③效率

硬件设备处于忙碌的时间占总时间的一个比例。所谓的设备指的就是我们之前提出的在不同的阶段所需要使用到的这些硬件设备

结合这个时空图来看的话，我们用红框框出来的部分就是设备处于忙碌的这些时间，而蓝色这个框又反映了整体的一个时间。

**计算这个流水线的效率**是不是只需要计算右半部分的这一整个矩形，占整体的一个比例，或者说只需要用n个任务所占的这个时空区的有效面积，除以这整体的时空区面积就可以了。

```
```

#### 🛫指令流水线的影响因素和分类

##### 🌏机器周期的设置

![image-20230506205818427](E:\每日三省吾身\imgs\image-20230506205818427.png)

基于五段式指令流水线(由MIPS架构提出)即所有的指令分为了5个机器周期(IF ID EX M WB)，大部分精简指令集系统来说。通常我们都会规定每一条指令所包含的机器周期数都相同，并且每一个机器周期的长度也都相同。这样可以方便我们安排指令流水线，每个阶段的耗时会向耗时最长的那个阶段靠近。

有些阶段会提前把数据准备好，故可将它们存入功能段部件后的缓冲寄存器当中

①ID指令译码阶段

在这个指令译码阶段，除了完成指令译码的工作之外。把这条指令所需要用到的操作数，从**通用寄存器里边把它取出来**，然后放到这个锁存器a和b里边。

和之前不一样的是：（比如加法指令）可以直接指明我要访问的那个加数，或者被加数，该操作所需要用到的操作数，**会直接来自于主存**。

在**RISC精简指令集系统**之下，我们想要进行运算的**操作数，一定是直接来自于通用寄存器**的。不可能直接来自于主存，如果要来自于主存，那么一定需要先把那个数据先放到通用寄存器，然后再从通用寄存器当中取出那个数据。

②执行阶段

用alu算术逻辑单元来处理。刚才前一个阶段取出的操作数

该阶段所含imm锁存器是用于存储立即数的，因为我们有的指令当中可能会使用立即寻址，也就是指令的地址码部分直接说明了一个立即数。在这种情况下，我们可以直接从指令当中取出该操作数，接下来执行阶段所需要使用的立即数，会把它放到这个锁存器里边。该阶段需要处理的数据其中一个是立即数，另一个来自于某一个通用寄存器。根据不同指令，**运算结果可能写回主存，也可能写回通用寄存器**。

##### 🌏影响流水线的因素

###### ①结构相关(资源冲突)

![image-20230506210908736](E:\每日三省吾身\imgs\image-20230506210908736.png)

相当于OS中的进程互斥。不同时期的不同指令访问同一个硬件部件会产生资源冲突。

<font face="STCAIYUN" color="redorange" size="5">解决方法👇</font>

> 后一相关指令暂停一周期	

> (多增加一个资源，且可并行访问使用)资源重复配置：

数据和指令放置在不同的存储体当中致使不同指令在不同阶段访问的Cash体是不同的。

###### 🔥数据冲突

![image-20230506211257352](E:\每日三省吾身\imgs\image-20230506211257352.png)

 R1执行的正确数据未写回通用寄存器之前，其它指令竟先后使用了改数据 。

<font face="STCAIYUN" color="redorange" size="5">解决方法👇</font>

> 硬件阻塞Stall或软件插入Nop空指令

<center class="half">   
    <img src="E:\每日三省吾身\imgs\image-20230506211410948.png" width="250" alt="Σ(っ °Д °;)っ显示失败"/>   
    <img src="E:\每日三省吾身\imgs\image-20230506211912948.png" width="250" alt="Σ(っ °Д °;)っ显示失败"/> </center>

> 数据旁路技术

r2和r3相加的结果其实在第三个阶段执行阶段。经过这个运算器的处理之后。是不是就已经有结果了？而第二条减法指令所需要用的其中一个操作数r1，不一定要从那个寄存器里取，我们可以增加一个电路直接从这个alu的输出端把它接到下一个alu的输入端，也就是直接把r2和r3相加的结果作为下一条指令的其中一个输入端，这样的话，第二条指令需要的这些数据就不需要等了

> 编译优化

![image-20230506212727929](E:\每日三省吾身\imgs\image-20230506212727929.png)



后面这些指令的执行不需要依赖前边这几条指令的一个运算结果，那么可以把这几条指令安排到第一条指令之后来执行。当减法操作这条指令执行的时候，事实上已经过了这三条指令的一个执行的那个周期了，就有点类似于我们之前在这个地方插入了空操作的三条指令是一样的效果，但是比起插入空操作的指令来说，把后续的那些指令提前到这个位置来执行，相当于这个时间没有浪费，我们在做有意义的事情，而不是在抖腿，不是在做空操作。所以**如果有后续的指令可以提前执行，不需要依赖于前序指令的一个执行结果**，可以用编译器来调整这个指令的执行顺序，从而就可以解决数据相关的问题。

###### ③控制相关

当我们遇到**转移指令或者改变PC值的指令而造成断流**的时候，会引起控制冲突。

![image-20230506214017247](E:\每日三省吾身\imgs\image-20230506214017247.png)

<font face="STCAIYUN" color="redorange" size="5">解决方法👇</font>

> 转移指令分支预测

>预测转移成功和不成功两个控制流方向上的目标指令

显然如果要**预取两个控制流方向上的指令**，那么我们可能会需要增加一些硬件部件。比如说增加两个指令寄存器之类的。

> 加快和提前形成条件码

比如在设计加法器的时候。需要把一位全加器进行一个串联，每一个全加器都会依赖于它前边这个全加器产生的进位信息，但是我们可以用电路改造的方式，**让这些进位信息提前的产生，提前的传递给前边的这些全加器**

> 提高转移方向的猜准率

是对第一种解决方法的一个优化，反正就是引入一些方法来提高我们猜准的那个概率



##### 🌏流水线的分类



指令执行分为不同的阶段，每一个阶段所需要用到的功能部件不一样。**部件功能级流水线**是把某一个阶段用到的那个功能部件再进一步的细分，比如说我们在指令的执行阶段，我们会把要运算的操作数送给alu，让它进行的浮点加法操作分别需要进行4个子过程 ，即需要被细分为四个分段。

处理机级流水即之前一直在讲的内容。

**处理机间流水**指让每一个处理机完成特定的工作，比如A完成求接差，B完成尾数相加...

②单功能和多功能流水线

可以专门的搞这样的一条流水线，就是来完成单一的浮点数加法的一个一个功能。这就是单功能的流水线。而多功能流水线，就是说我们这流水线可以完成不同的功能，指令流水线就是一个多功能流水线，对吧？因为指令流水线可以完成多种指令嘛，每一条指令它所表示的功能就是不一样的

③动态和静态流水线

实现一个呃浮点数加法的流水线。那么，如果**alu内部的各个部件在同一时间内**，它**只能完成这种浮点数加法的运算**，那这就是**静态流水线**

这个流水线上此时正在进行浮点加法运算，同时，还**有其他的一些运算相关的电路还在进行**比如说实现什么定点数的加法，这就是一个**动态流水线**

④线性流水线和非线性流水线

如果说我们的alu算术逻辑单元。它在执行阶段，它只支持加法，不支持乘法的话，那是不是就意味着当我们想要实现乘法运算的时候？这个alu它只能通过多次的加法来实现，每一次加法都需要消耗一个机器周期嘛，所以如果我们的alu没有乘法电路，只有加法电路。那么，在这种情况下，执行相关的这个功能段，这个功能段就有可能数次流过流水线。需要进行多次加法才可以完成乘法



##### 🌏流水线的多发技术

###### 超标量(空分复用技术)

![image-20230506221200844](E:\每日三省吾身\imgs\image-20230506221200844.png)

在这样的一个时钟周期内，我们可以并行的发射出多条指令，我们需要保证同时执行的这几条指令，在这种同时工作的情况下，不会出现问题

意味着至少我们需要配置三个指令寄存器，然后也有可能需要配置三个alu对吧？因此要实现超标量技术，那么我们**必须配置多个功能部件**。另外，我们程序里边所包含的**指令的执行顺序是不可以调整的**。

**有的CPU可能会支持指令的乱序发射**，那这一类的CPU就意味着即便我们给出的指令序列是1234这么排序的。但是呃，对于这种CPU来说，这个指令的顺序是可以调整的，可以在执行的时候动态的调整。

**指令的排列是由编译器决定的**，因此采用超变量技术，那么我们的编译优化技术的要求可能会比较高，需要考虑到哪些指令可以并行的运行，哪些不可以并行的运行

###### 超流水(时分复用技术)

![image-20230506221431382](E:\每日三省吾身\imgs\image-20230506221431382.png)

###### 超长指令字

![image-20230506221732150](E:\每日三省吾身\imgs\image-20230506221732150.png)

如果有**多条指令**它们在**执行阶段所需要用到的功能部件不一样**，那么这些指令的**功能**其实是**可以并行完成**的。

当**编译程序** 发现了这种**潜在的并行性**之后，会把多条可以并行操作的指令**组合成一整条超长的指令**。

这种超长的指令，其中**可能会包含多个操作码字段**，总长度有可能会达到几百个比特。那显然多种操作，**想让它们同时进行**，那么我们就必须**提供多个相互独立的处理部件**。

```
```

#### 🛫五段式指令流水线

接下来常考类型指令的执行过程

##### 🌏运算类指令的执行过程

举例（Rs指源操作数，Rd指目的操作数）

```
ADD Rs , Rd
ADD #857 , Rd
SHL , Rd
```

![image-20230507210909115](E:\每日三省吾身\imgs\image-20230507210909115.png)

要根据PC程序计数器所指明的位置去指令cache(Instruction Cache)当中取出当前的这条指令，然后把这条指令放到IF段的锁存器里边。

ID译码阶段需要完成两个事，一要对指令的操作码进行译码，还需要把当前的这条指令所需要用到的操作数，把它们取到ID段的储存器里边，那可以看到ID段有三个储存器A、B、imm(存放立即数immediately)。根据不同的指令，下一段所需要用到的操作数放到锁存器的情况会不同。对于第一条指令来说，就是要把两个操作数分别的放到a和b这两个锁存器里边。第二条指令的其中一个操作数是一个立即数。因此，第二条指令的ID功能段会把其中一个目的操作数放到锁存器A里，然后再把指令里边指明的这个立即数857，放到锁存器imm里。

对于精简指令集系统，在<u>访存阶段，运算类的指令是不需要做任何事情的</u>，执行阶段的运算结果一定是存入某一个寄存器(此处指令是将结果写入了访存阶段的锁存器当中)，而不可能直接写回主存。<u>但是其所经历的时间是必须消耗的</u>，因为之前提到过：为了方便流水线的安排，应当让所有的指令都统一。

写回阶段可以直接把，保存在访存阶段的锁存器中的执行运算结果，将它写回某一个通用寄存器当中。



##### LOAD取数指令

①指令解释

Load Rd , 996(Rs)	是指在Rs这个寄存器的值的基础上，与996的相加结果作为有效地址。将这个地址所对应的主存单元里边所存放的数据，把它取到rd寄存器当中。

Load Rd,mem	用mem表示此次要访问的主存地址，把这个地址所对应的内容取到rd寄存器当中

②执行过程分析

IF...ID阶段译码分析并将指令指明的基址寄存器里的值，给存入锁存器A中，然后把立即数996放入锁存器imm当中。执行阶段将两者运算结果放入锁存器当中，访存阶段根据这玩意儿从Data Cache取数，并放入M功能段的锁存器里边(和Data Cache接近的片段)，写回阶段将该操作数写回寄存器。

![image-20230507214047309](E:\每日三省吾身\imgs\image-20230507214047309.png)

Store指令在ID阶段会另外，将Rs寄存器(当前要存的数)放入锁存器B当中，执行阶段会将锁存器B当中的内容放入”Store“当中，访存阶段根据运算结果即有效地址，将Store中数据存到对应位置即可，<u>写回阶段无需工作。</u>

要保证每一个阶段的功能，在一个节拍(时钟周期)内就可以完成，那么显然，如果在这个阶段对主存进行访问，那么一个时钟周期内肯定是完成不了的。所以为了保证流水线的流畅工作，通常我们访问主存的时候，大概率情况下都可以在data cache当中直接找到我们想要的数据。

只有Load Store两个指令才可以访问主存，**其他所有的指令在执行过程当中都不会直接访问主存**。其他指令想要得到的数据一定是**直接来自于某一个寄存器，或者就是指令当中直接包含的某一个立即数**。



##### 转移类指令

①一般采用相对寻址(相对于PC的偏移量)，若转移条件满足，将从下一条指令的地址开始偏移(**(PC)+指令字长**)，否则在IF阶段结束后自动+'1'

**访存阶段不会对Cache进行数据访问，反而会修改PC的值(需要转移至位置)**，且修改PC值也不是在写回阶段进行的，写回阶段一般会修改通用寄存器中的值。故写回阶段啥也不干。

(了解即可)指令来说，最后这个**写回阶段是什么也不用做的**，很多教材会把写回PC的这个功能段。称为wrPC这样的一个段。这个功能段在逻辑上并不属于访存阶段，也不属于写回阶段，但是由于这个功能段所需要使用到的硬件部件，和这儿我们画出的五个功能段都是相互独立的，同时写回PC(wrPC)的这个功能段，它所需要的耗时也比第四个阶段访存段要更短。因此，我们可以把写回PC这个功能段的实际的处理放在第四个阶段来进行。

![image-20230507215834735](E:\每日三省吾身\imgs\image-20230507215834735.png)

②对于无条件转移指令，不需要判断任何条件，因此其实第三个阶段用不到alu算术逻辑单元。而是会直接根据这个偏移量，把我们目标的PC值直接写回到PC寄存器里边，写回PC的这个功能段，这个功能段又会被安排在EX这个阶段来执行，接下来的访存和写回阶段就不需要做任何事情好，那由于写回PC的这个功能段所需要的耗时要比EX这个段更短，所以我们同样的可以把它安排在第三段时间内来完成

**❓为什么需要尽早地修改PC值，将WrPC放在第三阶段处理？**

在指定流水线里边，按理来说，我们应该是顺序的一条一条的取出指令的，但是由于这种呃转移类的指令。可能会修改PC的值，因此如果一直都是顺序的取出后续指令，那么后续取出的这些指令也许并不是我们接下来应该执行的指令。那这种情况下就发生了控制冲突



![image-20230507221057524](E:\每日三省吾身\imgs\image-20230507221057524.png)

```
```

### 🌆多处理器系统以及硬件多线程(要求”基础概念“指考选择题)

整个课程围绕**SISD**进行讲解，整个系统当中只有一个主存储器，一个单核的处理器，一个cu控制单元。

#### 单指令流单数据流 

![image-20230507221954602](E:\每日三省吾身\imgs\image-20230507221954602.png)



**单核单指令流**指CPU在<u>同一时间段内只能处理一个指令序列</u>，各个进程的指令序列只能并发地执行，不能并行地执行。**单数据流**是指每一条指令它只能处理1~2个数据比如ADD指令和LOAD指令。 

每一个指令段都会给它设置一些特定的这个功能部件。各个功能部件可以并行的工作，另外<u>**为了提升访存读写的效率**</u>，因此我们**会采取多模块交叉存储器**。

```
```

#### 单指令流多数据流

**什么时候会用到SIMD呢**❓

需要**重复处理大量的类似的数据**：①比如给像素含量极大的图片加滤镜，需要对每一个像素点的RGB值进行相同的处理，并且由于像素点数据结构类似，故可以将图片拆分成多块分别存入**不同的局部存储器**当中，可以让同一个指令同时向多个部件发出相同的控制信号，使得一条指令能够并行处理多个数据，但注意指令序列是不能并行的。



**为什么每个硬件都含独立的存储器**❓

因为各个局部寄存器的执行速度可能不同，且各个部分处理的数据，它存放的位置不一样，当然也需要使用到各自的地址寄存器组记录各自的执行位置。

```
```

#### 多指令流单数据流

啥也不是

```
```

#### 多指令流多数据流

![image-20230507224006965](E:\每日三省吾身\imgs\image-20230507224006965.png)

多个核可以执行不同的指令序列，当然它们也可以并行地处理多个数据流，多个不同的数据。

**线程级并行**是指每一个核可以运行各自的线程，多个线程是可以并行的执行的，那么线程级以上并行是是指进程级的并行。~~每一个和分别处理一个进程~~

```
```

###### **多处理器系统**

**多处理器系统**是一个简称，它的全称是共享内存。各个处理器之间的各个核心之间都可以通过load store指令访问**同一个主存**。可以通过主存来相互的传递数据，🌰比如你的手机，你的电脑只有一个主存，那每一个核心它都可以通过load或者store指令来访问你的主存。所有的这些核心，他们共享同一个物理地址空间，同时，他们也共享最低一级的这个cash，而更高级别更快的Cash专属于某一个核。因此**这些核心想要相互传递数据可以通过LLC(最低一级)或通过主存进行，也就是将数据反复放入其中再反复拿出的过程**。

```
```

###### **多计算机系统**

![image-20230508205549655](E:\每日三省吾身\imgs\image-20230508205549655.png)

每一台计算机限制在各自的局域网内，仅能通过消息传递实现通信，只能访问自身的主存储器。

一个大的任务，我可以把它拆分为三个独立的子任务，那三个独立的子任务分别，可将它们分派给不同的计算机，那各个计算机之间执行这些任务，处理这些**指令序列是并行**的，每一台计算机在执行各自指令的时候，他们所处理的数据肯定也各不相同，因此**数据流也是并行**的

```
```

#### 向量处理器 

一个具体的数值就是一个标量

普通的标量处理器当中，要完成两个N维向量的相加，我们就需要执行n次加法指令。n次加法指令在一个向量处理器当中，我们只需要执行一次加法指令就可以。所以这种处理器它可以**实现数据集的运行**。那在超级计算机当中，可能会有一个超大的主存，同时也会有多个向量处理器都需要访问这个主存。那**由于数据的读写量大**，因此在这种系统当中，**通常这个主存需要支持多端口同时读取**。

```
```

共享内存多处理器和多核处理器是同一个东西，前者强调的是各个处理器，各个核心可以共享同一个主存，并且多个处理器，它们的地址，空间都是可相同共享的，都可以通过load和store指令来访问这个共享的主存储器。

后者更强调的是一个CPU芯片里边包含多个处理器，也就是多个核。那由于多个运算核心都集成在同一块芯片上，因此也把它称为片级多处理器。

都属于mind。

```
```

### 硬件多线程 

![image-20230508210604484](E:\每日三省吾身\imgs\image-20230508210604484.png)

（不太严谨地理解）①对于细粒度一个时钟周期将线程的俩指令可能会用到不同的功能部件且处理器中存在俩IR，故可并行运行 。每一轮时钟周期都可能会切换线程 ②对于粗粒度中，流水线阻塞事件比如Cache缺失 。啥是重载不用深究，但代价高。





![image-20230508211240083](E:\每日三省吾身\imgs\image-20230508211240083.png)

传统的这种不支持硬件多线程的处理器上，我们要进行线程之间的切换，就需要去保存和恢复。线程的运行环境主要就是保存和恢复这些寄存器的值，这个保存和恢复的过程就给线程切换带来不小的代价

支持硬件多线程的处理器中，由于不同线程的运行环境包括PC值存储在不同的寄存器组中，故当这俩线程想要同时运行时，不需要将寄存器组中的内容保存到主存当中，即无需恢复线程。